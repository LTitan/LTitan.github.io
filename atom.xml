<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LTitan`s Blog</title>
  
  <subtitle>foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://LTitan.github.io/"/>
  <updated>2018-10-25T02:01:40.676Z</updated>
  <id>https://LTitan.github.io/</id>
  
  <author>
    <name>lyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于ORB的图像矫正</title>
    <link href="https://LTitan.github.io/2018/07/25/%E5%9F%BA%E4%BA%8Eorb%E7%9A%84%E5%9B%BE%E5%83%8F%E7%9F%AB%E6%AD%A3/"/>
    <id>https://LTitan.github.io/2018/07/25/基于orb的图像矫正/</id>
    <published>2018-07-25T04:30:22.000Z</published>
    <updated>2018-10-25T02:01:40.676Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单应性矩阵"><a class="markdownIt-Anchor" href="#单应性矩阵"></a> 单应性矩阵</h1><p>在二维平面上，平面的单应性被定义为从一个平面到另一个平面的投影映射，就像我们拍一张照片时，从我们眼前的点一一映射到摄像机内部一样。英文学名叫做homography（单应性，ps:下面的鲁棒性就是稳定性。</p><p>下即为一个简单的3x3homo矩阵</p><p class="katex-block katex-error" title="ParseError: KaTeX parse error: Expected &amp; or \\ or \end at position 39: …00 &amp; h01 &amp; h02 \̲̲h10 &amp; h11 &amp; h12…">\left[\begin{matrix}h00 &amp; h01 &amp; h02 \h10 &amp; h11 &amp; h12 \h20 &amp; h21 &amp; h22\end{matrix}\right] \tag{1}</p><p>其平面坐标变换对应为(原坐标为(x1,y1),其变换为(x2,y2)):</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>1</mn></msub><mtext> </mtext><msub><mi>y</mi><mn>1</mn></msub><mtext> </mtext><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mi>H</mi><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>2</mn></msub><mtext> </mtext><msub><mi>y</mi><mn>2</mn></msub><mtext> </mtext><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>0</mn><mn>0</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>0</mn><mn>1</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>0</mn><mn>2</mn></mrow><mtext> </mtext><mi>h</mi><mrow><mn>1</mn><mn>0</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>1</mn><mn>1</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>1</mn><mn>2</mn></mrow><mtext> </mtext><mi>h</mi><mrow><mn>2</mn><mn>0</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>2</mn><mn>1</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>h</mi><mrow><mn>2</mn><mn>2</mn></mrow></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>2</mn></msub><mtext> </mtext><msub><mi>y</mi><mn>2</mn></msub><mtext> </mtext><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}x_1 \ y_1 \ 1\end{array}\right] = H \left[\begin{array}{c}x_2 \ y_2 \ 1\end{array}\right] = \left[\begin{array}{ccc}h{00} &amp; h{01} &amp; h{02} \ h{10} &amp; h{11} &amp; h{12} \ h{20} &amp; h{21} &amp; h_{22} \end{array} \right] \left[ \begin{array}{c} x_2 \ y_2 \ 1 \end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">0</span><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">0</span><span class="mord">2</span></span><span class="mspace"> </span><span class="mord mathit">h</span><span class="mord"><span class="mord">1</span><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">1</span><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">1</span><span class="mord">2</span></span><span class="mspace"> </span><span class="mord mathit">h</span><span class="mord"><span class="mord">2</span><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">2</span><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span></span></p><p>下图为变换的例子</p><p><img src="https://www.learnopencv.com/wp-content/uploads/2016/01/homography-example.jpg" alt="alt"></p><p>在OpenCV里面，单应矩阵的计算函数为 :</p><p>Mat findHomography(inputArray points1,inputArray points2,int method)</p><p>. 参数一为输入的x1，y1 点集</p><p>. 参数二为输入的 x2，y2 点集</p><p>. 参数三为计算方法：0 - 使用所有点的常规方法 RANSAC - 基于RANSAC的鲁棒方法 LMEDS - 最小中值稳健方法 RHO - 基于PROSAC的鲁棒方法</p><p>#关键点检测</p><p>上篇里有介绍基于ORB的关键点检测，舒服的是这个算法是至今最好最快的算法，其他的检测算法还有SURF，SIFT，etc….算法，效率而讲，500点一下还是差不多的，但是点越多的话ORB绝对胜出。</p><p>#关键点匹配<br>上篇的文章依然用着老的api，但是编译了最新的3.4之后api又发生了变化(mmp)，这次能直接detect 和compute一起用了。</p><p>其用到头文件 xfeatures2d/nonfree.hpp</p><p>命名空间 cv::xfeatures2d</p><p>检测器创建如下，只能处理灰度图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ptr&lt;Feature2D&gt; orb = ORB::create(MAX_FEATURES);//智能指针传参为最大检测点数</span><br></pre></td></tr></table></figure><p><img src="/images/2018/07/match2.jpg" alt=""></p><p>图像矫正如下:</p><p><img src="/images/2018/07/change.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include &lt;opencv2/xfeatures2d/nonfree.hpp&gt;</span><br><span class="line">#include &lt;opencv2/features2d.hpp&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace  cv;</span><br><span class="line">using namespace cv::xfeatures2d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const int MAX_FEATURES = 500;</span><br><span class="line">const float GOOD_MATCH_PERCENT = 0.15f;</span><br><span class="line"></span><br><span class="line">void alignImage(Mat&amp; img1, Mat&amp; img2, Mat&amp; dst, Mat h)</span><br><span class="line">&#123;</span><br><span class="line">Mat img1Gray, img2Gray;//灰度图</span><br><span class="line">cvtColor(img1, img1Gray, COLOR_BGR2GRAY);</span><br><span class="line">cvtColor(img2, img2Gray, COLOR_BGR2GRAY);//灰度处理</span><br><span class="line"></span><br><span class="line">vector&lt;KeyPoint&gt; keypoints1, keypoints2;//图1 关键点 图2 关键点</span><br><span class="line">Mat descriptors1, descriptors2;</span><br><span class="line">Ptr&lt;Feature2D&gt; orb = ORB::create(MAX_FEATURES);</span><br><span class="line"></span><br><span class="line">orb-&gt;detectAndCompute(img1Gray, Mat(), keypoints1, descriptors1);//检测匹配</span><br><span class="line"></span><br><span class="line">orb-&gt;detectAndCompute(img2Gray, Mat(), keypoints2, descriptors2);//检测匹配</span><br><span class="line"></span><br><span class="line">vector&lt;DMatch&gt; matches;</span><br><span class="line">Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::create(&quot;BruteForce-Hamming&quot;);</span><br><span class="line"></span><br><span class="line">matcher-&gt;match(descriptors1, descriptors2, matches, Mat());//匹配描线</span><br><span class="line"></span><br><span class="line">sort(matches.begin(), matches.end());//排序筛选优好的点</span><br><span class="line"></span><br><span class="line">const int numGoodMatches = matches.size()*GOOD_MATCH_PERCENT;</span><br><span class="line"></span><br><span class="line">matches.erase(matches.begin() + numGoodMatches, matches.end());</span><br><span class="line"></span><br><span class="line">Mat imMatches;</span><br><span class="line"></span><br><span class="line">drawMatches(img1, keypoints1, img2, keypoints2, matches, imMatches);</span><br><span class="line">imshow(&quot;match&quot;, imMatches);</span><br><span class="line">imwrite(&quot;F:\\match.jpg&quot;, imMatches);</span><br><span class="line">vector&lt;Point2f&gt; points1, points2;</span><br><span class="line">for (auto x : matches)</span><br><span class="line">&#123;</span><br><span class="line">points1.push_back(keypoints1[x.queryIdx].pt);</span><br><span class="line">points2.push_back(keypoints2[x.trainIdx].pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h = findHomography(points1, points2, RANSAC);</span><br><span class="line">warpPerspective(img1, dst, h, img2.size());//旋转矫正</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">string refFilename=&quot;F:\\picture\\src.jpg&quot;;//原图路径</span><br><span class="line"></span><br><span class="line">Mat src = imread(refFilename);</span><br><span class="line">string scanFilename = &quot;F:\\picture\\scanned.jpg&quot;;//扫描的或者电子版的图</span><br><span class="line">Mat scan_src = imread(scanFilename);</span><br><span class="line"></span><br><span class="line">Mat imageRege, homo;//完成图像 和 homo矩阵</span><br><span class="line">alignImage(src, scan_src, imageRege, homo);</span><br><span class="line">cout &lt;&lt; homo &lt;&lt; endl;</span><br><span class="line">imshow(&quot;dst&quot;, imageRege);</span><br><span class="line">imwrite(&quot;F:\\change.jpg&quot;, imageRege);</span><br><span class="line">waitKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单应性矩阵&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单应性矩阵&quot;&gt;&lt;/a&gt; 单应性矩阵&lt;/h1&gt;
&lt;p&gt;在二维平面上，平面的单应性被定义为从一个平面到另一个平面的投影映射，就像我们拍一张照片时，从我们眼前的点一一映射到摄像机内部一
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv:基于ORB特征点匹配及图像拼接</title>
    <link href="https://LTitan.github.io/2018/07/21/opencv-%E5%9F%BA%E4%BA%8EORB%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E5%8F%8A%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5/"/>
    <id>https://LTitan.github.io/2018/07/21/opencv-基于ORB特征点匹配及图像拼接/</id>
    <published>2018-07-21T02:18:59.000Z</published>
    <updated>2018-09-25T09:25:38.824Z</updated>
    
    <content type="html"><![CDATA[<p>#ORB简述<br>ORB（Oriented FAST and Rotated BRIEF）是一种快速特征点提取和描述的算法。ORB算法分为两部分，分别是特征点提取和特征点描述。特征提取是由FAST（Features from Accelerated Segment Test）算法发展来的，特征点描述是根据BRIEF（Binary Robust IndependentElementary Features）特征描述算法改进的。ORB特征是将FAST特征点的检测方法与BRIEF特征描述子结合起来，并在它们原来的基础上做了改进与优化。</p><p>下图是我在高数课本上进行的测试:</p><p><img src="/images/2018/07/ORB.jpg" alt="alt"></p><p>#特征点匹配</p><p>例子里采集了3000个点吧对比一下，opencv3.3以后好像用上了智能指针Ptr对象，对象的创建只能用ptr模板创建，大概是因为图像再处理的过程中防止异常错误正常抛出吧。<br>两张原图：</p><p><img src="/images/2018/07/yy.jpg" alt="alt"><br><img src="/images/2018/07/zz.jpg" alt="alt"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Mat image_src1,image_src2;</span><br><span class="line">   Mat image_gray1,image_gray2;</span><br><span class="line">   image_src1=imread(&quot;D:\\yy.jpg&quot;);</span><br><span class="line">   cvtColor(image_src1,image_gray1,COLOR_BGR2GRAY);//转为灰度图</span><br><span class="line">   image_src2=imread(&quot;D:\\zz.jpg&quot;);</span><br><span class="line">   cvtColor(image_src2,image_gray2,COLOR_BGR2GRAY);//转为灰度图</span><br><span class="line"></span><br><span class="line">   Ptr&lt;Feature2D&gt; oDetectors=ORB::create(3000);//创建orb对象，采集特征点</span><br><span class="line">   vector&lt;KeyPoint&gt; KeyPoints1,KeyPoints2;//关键点数组</span><br><span class="line"></span><br><span class="line">   oDetectors-&gt;detect(image_gray1,KeyPoints1);//采集左图特征点</span><br><span class="line">   oDetectors-&gt;detect(image_gray2,KeyPoints2);//采集右图特征点</span><br><span class="line"></span><br><span class="line">   Mat imageDec1,imageDec2;</span><br><span class="line">   Ptr&lt;Feature2D&gt; ptor=ORB::create();//创建一个新的oeb对象，当然也可以用上面那个</span><br><span class="line">   ptor-&gt;compute(image_gray1,KeyPoints1,imageDec1);//描述特征点</span><br><span class="line">   ptor-&gt;compute(image_gray2,KeyPoints2,imageDec2);//描述特征点</span><br><span class="line"></span><br><span class="line">   flann::Index flannIndex(imageDec1,LshIndexParams(12,20,2),</span><br><span class="line">                           cvflann::FLANN_DIST_HAMMING);</span><br><span class="line"></span><br><span class="line">   vector&lt;DMatch&gt; goodMatchPoints;</span><br><span class="line">   Mat matchIndex(imageDec2.rows,2,CV_32SC1);</span><br><span class="line">   Mat matchDistance(imageDec2.rows,2,CV_32FC1);</span><br><span class="line"></span><br><span class="line">   flannIndex.knnSearch(imageDec2,matchIndex,matchDistance,2,flann::SearchParams());//采用k近似值 将匹配的索引和距离计算出来</span><br><span class="line"></span><br><span class="line">   for(int i=0;i &lt; matchDistance.rows;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       float t=matchDistance.at&lt;float&gt;(i,0);</span><br><span class="line">       float s=matchDistance.at&lt;float&gt;(i,1);</span><br><span class="line">       if(t&lt;s*0.46)//相似度大约为0.46就算相符</span><br><span class="line">       &#123;</span><br><span class="line">           DMatch part_matches(i,matchIndex.at&lt;int&gt;(i,0),t);</span><br><span class="line">           goodMatchPoints.push_back(part_matches);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   Mat first_matching;</span><br><span class="line">   drawMatches(image_src2,KeyPoints2,image_src1,KeyPoints1,</span><br><span class="line">               goodMatchPoints,first_matching);</span><br><span class="line">   imshow(&quot;Match&quot;,first_matching);</span><br></pre></td></tr></table></figure><p>如图，匹配完成:<br><img src="/images/2018/07/match.jpg" alt="alt"></p><p>#拼接<br>记录相似点，将另一图像适度旋转调整，然后拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Point2f&gt; Conners(4);// 左上角 左下角 右上角 右下角</span><br><span class="line"></span><br><span class="line">void calcCorners(const Mat&amp; homo,const Mat&amp; input)</span><br><span class="line">&#123;</span><br><span class="line">    double v2[]=&#123;0,0,1&#125;;</span><br><span class="line">    double v1[3];//改变后值</span><br><span class="line">    Mat V2=Mat(3,1,CV_64FC1,v2);</span><br><span class="line">    Mat V1=Mat(3,1,CV_64FC1,v1);</span><br><span class="line">    //下面都是重复代码计算看懂一个即可</span><br><span class="line">    V1=homo*V2;</span><br><span class="line">    Conners[0].x=v1[0]/v1[2];</span><br><span class="line">    Conners[0].y=v1[1]/v1[2];</span><br><span class="line"></span><br><span class="line">    v2[0]=0;</span><br><span class="line">    v2[1]=input.rows;</span><br><span class="line">    v2[2]=1;</span><br><span class="line">    V2=Mat(3,1,CV_64FC1,v2);</span><br><span class="line">    V1=Mat(3,1,CV_64FC1,v1);</span><br><span class="line">    V1=homo*V2;</span><br><span class="line">    Conners[1].x=v1[0]/v1[2];</span><br><span class="line">    Conners[1].y=v1[1]/v1[2];</span><br><span class="line"></span><br><span class="line">    v2[0]=input.cols;</span><br><span class="line">    v2[1]=0;</span><br><span class="line">    v2[2]=1;</span><br><span class="line">    V2=Mat(3,1,CV_64FC1,v2);</span><br><span class="line">    V1=Mat(3,1,CV_64FC1,v1);</span><br><span class="line">    V1=homo*V2;</span><br><span class="line">    Conners[2].x=v1[0]/v1[2];</span><br><span class="line">    Conners[2].y=v1[1]/v1[2];</span><br><span class="line"></span><br><span class="line">    v2[0]=input.cols;</span><br><span class="line">    v2[1]=input.rows;</span><br><span class="line">    v2[2]=1;</span><br><span class="line">    V2=Mat(3,1,CV_64FC1,v2);</span><br><span class="line">    V1=Mat(3,1,CV_64FC1,v1);</span><br><span class="line">    V1=homo*V2;</span><br><span class="line">    Conners[3].x=v1[0]/v1[2];</span><br><span class="line">    Conners[3].y=v1[1]/v1[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main:://此处接着标题二的代码</span><br><span class="line"></span><br><span class="line">vector&lt;Point2f&gt; image_points1,image_points2;</span><br><span class="line"></span><br><span class="line">    for(auto x:goodMatchPoints)</span><br><span class="line">    &#123;</span><br><span class="line">        image_points2.push_back(KeyPoints2[x.queryIdx].pt);</span><br><span class="line">        image_points1.push_back(KeyPoints1[x.trainIdx].pt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat homo=findHomography(image_points1,image_points2,CV_RANSAC);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;homo matrix:&quot;&lt;&lt;homo&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    calcCorners(homo,image_src1);</span><br><span class="line">    Mat imageTransform1,imageTransform2;</span><br><span class="line">    warpPerspective(image_src1,imageTransform1,homo,Size(max(Conners[2].x,</span><br><span class="line">                    Conners[3].x),image_src2.rows));</span><br><span class="line">    imshow(&quot;12&quot;,imageTransform1);</span><br><span class="line"></span><br><span class="line">    int dst_width=imageTransform1.cols;</span><br><span class="line">    int dst_height=image_src2.rows;</span><br><span class="line"></span><br><span class="line">    Mat dst(dst_height,dst_width,CV_8UC3);</span><br><span class="line">    dst.setTo(0);</span><br><span class="line">    imageTransform1.copyTo(dst(Rect(0,0,imageTransform1.cols,imageTransform1.rows)));</span><br><span class="line"></span><br><span class="line">    image_src2.copyTo(dst(Rect(0,0,image_src2.cols,image_src2.rows)));</span><br><span class="line">    imshow(&quot;pin&quot;,dst);</span><br></pre></td></tr></table></figure><p>拼接完，如图：<br><img src="/images/2018/07/pin.jpg" alt="alt"></p><p>#优化拼接处<br>此处是借鉴别人的，因为自己也不可能凭空想到，哈哈，修复拼接处的线条问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void optimizated(Mat &amp;src,Mat &amp;trans,Mat &amp;dst)</span><br><span class="line">&#123;</span><br><span class="line">    int start=min(Conners[0].x,Conners[1].x);</span><br><span class="line">    double processWidth=src.cols-start;</span><br><span class="line"></span><br><span class="line">    int rows=dst.rows;</span><br><span class="line">    int cols=src.cols;</span><br><span class="line">    double alpha=1;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;rows;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar *p=src.ptr&lt;uchar&gt;(i);</span><br><span class="line">        uchar *t=trans.ptr&lt;uchar&gt;(i);</span><br><span class="line">        uchar *d=dst.ptr&lt;uchar&gt;(i);</span><br><span class="line">        for(int j=start;j&lt;cols;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            int k=j*3;</span><br><span class="line">            if(t[k]==0&amp;&amp;t[k+1]==0&amp;&amp;t[k+2]==0) alpha=1;</span><br><span class="line">            else alpha=(processWidth-j+start)/processWidth;</span><br><span class="line"></span><br><span class="line">            d[k]=p[k]*alpha+t[k]*(1-alpha);</span><br><span class="line">            d[k+1]=p[k+1]*alpha+t[k+1]*(1-alpha);</span><br><span class="line">            d[k+2]=p[k+2]*alpha+t[k+2]*(1-alpha);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成品图效果如下:</p><p><img src="/images/2018/07/over.jpg" alt="alt"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#ORB简述&lt;br&gt;
ORB（Oriented FAST and Rotated BRIEF）是一种快速特征点提取和描述的算法。ORB算法分为两部分，分别是特征点提取和特征点描述。特征提取是由FAST（Features from Accelerated Segment Te
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(四) 双向循环链表</title>
    <link href="https://LTitan.github.io/2018/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%9B%9B)%20%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%20/"/>
    <id>https://LTitan.github.io/2018/07/16/数据结构(四) 双向循环链表 /</id>
    <published>2018-07-16T05:16:59.000Z</published>
    <updated>2018-10-25T01:59:30.976Z</updated>
    
    <content type="html"><![CDATA[<p>又来安利福利了，双向和循环一起了吧，单讲双向没意思，结合在一起就有意思了，看完了第一篇的单链表应该看双向很轻松了。</p><p>运行截图</p><p><img src="/images/2018/07/dl.png" alt="alt"></p><p>遗憾没有放上查找，请自己加上吧，正序找逆序找都是easy的</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">//双向循环链表  基本操作和单链表差不多，只不过他有自己的回头路了</span><br><span class="line"></span><br><span class="line">typedef struct _double_linked_list</span><br><span class="line">&#123;</span><br><span class="line">    int data;//存放数据</span><br><span class="line">     struct _double_linked_list *front;//前指针</span><br><span class="line">     struct _double_linked_list *next;//后指针</span><br><span class="line"></span><br><span class="line">&#125;DouLinkedList;</span><br><span class="line"></span><br><span class="line">void traversing_postive(DouLinkedList *list)//正序遍历从头到尾</span><br><span class="line">&#123;</span><br><span class="line">   DouLinkedList *p=list-&gt;next;</span><br><span class="line">   DouLinkedList *head=list;//起始头位置</span><br><span class="line">   while(p!=head)//循环到头部就停止</span><br><span class="line">   &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void traversing_reverse(DouLinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">        DouLinkedList *p=list-&gt;front;</span><br><span class="line">        DouLinkedList *head=list;</span><br><span class="line">        while(p!=head)//循环到头部就停止</span><br><span class="line">        &#123;</span><br><span class="line">             printf(&quot;%d  &quot;,p-&gt;data);</span><br><span class="line">             p=p-&gt;front;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void create_tail(DouLinkedList *list,const int n)//n还是创建的长度</span><br><span class="line">&#123;</span><br><span class="line">        DouLinkedList *p=list;</span><br><span class="line">        DouLinkedList *head=list;</span><br><span class="line">        p-&gt;front=NULL;</span><br><span class="line">        p-&gt;next=NULL;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            DouLinkedList *temp; int data;</span><br><span class="line">            temp=(DouLinkedList*)malloc(sizeof(DouLinkedList));</span><br><span class="line">            printf(&quot;请输入第%d个结点的数据\n&quot;,i+1);</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;data);</span><br><span class="line">            temp-&gt;data=data;</span><br><span class="line"></span><br><span class="line">            head-&gt;front=temp;//头的前面指向插入的尾部</span><br><span class="line">            temp-&gt;next=head;//尾的下一个指向头部  这样就构成循环链表了</span><br><span class="line">            p-&gt;next=temp;</span><br><span class="line">            temp-&gt;front=p;</span><br><span class="line">            p=temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int insert_node(DouLinkedList *list,int pos,int data)</span><br><span class="line">&#123;</span><br><span class="line">        //链表的下标从1开始</span><br><span class="line">        if(pos&lt;1||list==NULL) return -1;//位置小于或者链表是空的 插入失败</span><br><span class="line"></span><br><span class="line">        DouLinkedList *head=list;</span><br><span class="line">        DouLinkedList *p=list-&gt;next;</span><br><span class="line"></span><br><span class="line">        int i=1;//计数i</span><br><span class="line">        while(p!=head)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==pos) break;//找到前驱点就停止</span><br><span class="line">            ++i;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;pos) return -1;//越界</span><br><span class="line">        DouLinkedList *newNode=(DouLinkedList*)malloc(sizeof(DouLinkedList));</span><br><span class="line">        newNode-&gt;data=data;</span><br><span class="line">        newNode-&gt;front=p-&gt;front;</span><br><span class="line">        p-&gt;front-&gt;next=newNode;</span><br><span class="line">        newNode-&gt;next=p;</span><br><span class="line">        p-&gt;front=newNode;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int delete_node(DouLinkedList *list,int pos)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pos&lt;1||list==NULL) return -1;</span><br><span class="line"></span><br><span class="line">        DouLinkedList *p=list-&gt;next;</span><br><span class="line">        DouLinkedList *head=list;</span><br><span class="line">        int i=1;</span><br><span class="line">        while(p!=head)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==pos) break;</span><br><span class="line">            ++i;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;pos) return -1;</span><br><span class="line">        p-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;front=p-&gt;front;</span><br><span class="line">        free(p);</span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        DouLinkedList *mylist;</span><br><span class="line">        mylist=(DouLinkedList*)malloc(sizeof(DouLinkedList));//新建一个头节点</span><br><span class="line"></span><br><span class="line">        create_tail(mylist,5);</span><br><span class="line">        printf(&quot;正序遍历&quot;);</span><br><span class="line">        traversing_postive(mylist);</span><br><span class="line">        printf(&quot;逆序遍历&quot;);</span><br><span class="line">        traversing_reverse(mylist);</span><br><span class="line"></span><br><span class="line">        int flag=insert_node(mylist,2,666);//在第二个插入666</span><br><span class="line"></span><br><span class="line">        if(flag!=-1) puts(&quot;插入成功&quot;);</span><br><span class="line">        else puts(&quot;插入失败&quot;);</span><br><span class="line">        traversing_postive(mylist);</span><br><span class="line"></span><br><span class="line">        flag=delete_node(mylist,3);//删除第三个</span><br><span class="line">        if(flag!=-1) puts(&quot;删除成功&quot;);</span><br><span class="line">        else puts(&quot;删除失败&quot;);</span><br><span class="line">        traversing_postive(mylist);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又来安利福利了，双向和循环一起了吧，单讲双向没意思，结合在一起就有意思了，看完了第一篇的单链表应该看双向很轻松了。&lt;/p&gt;
&lt;p&gt;运行截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/07/dl.png&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;
&lt;p&gt;遗憾没有放上查找
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(二) 字符串的常规使用</title>
    <link href="https://LTitan.github.io/2018/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8%20/"/>
    <id>https://LTitan.github.io/2018/07/16/数据结构(二) 字符串的常规使用 /</id>
    <published>2018-07-16T01:44:59.000Z</published>
    <updated>2018-09-25T09:38:44.015Z</updated>
    
    <content type="html"><![CDATA[<p>虽然字符串简单，但是在生活中的用处确实很广，就像论文查重，文章检索，没有字符串的数据结构和算法是实现不了的</p><p>我在这先放上c语言版的char数组，文章的下篇将介绍c++版的（唉，这两天感觉自己特别能得吧了）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    #include &lt;stdlib.h&gt;</span><br><span class="line">    #include &lt;string.h&gt;</span><br><span class="line">    #include &lt;memory.h&gt;</span><br><span class="line"></span><br><span class="line">    //简单点说字符串就是字符数组</span><br><span class="line">    //基本运算无非就是长度 比较 回文 模式匹配(查找)</span><br><span class="line">    //模式匹配和回文我将会单独开文章的,请耐心等等吧 = =</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //1.求字符串的长度  这里用到strlen函数</span><br><span class="line">    //那为什么不用sizeof(str)/sizeof(char) 计算呢？</span><br><span class="line">    //原因是开辟了1024个长度不一定用满，用sizeof计算呢即为1024,而非字符串长度</span><br><span class="line">    int str_length(char *s)</span><br><span class="line">    &#123;</span><br><span class="line">        return strlen(s);//直接用strlen求解</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.字符串比较 就是挨个比较字符串的字符</span><br><span class="line">    //可以用strcmp函数比较  也可以自己手写一个</span><br><span class="line">    int str_comparison_system(char *p,char *q)//函数意思为调用系统函数</span><br><span class="line">    &#123;</span><br><span class="line">        //返回1 即p大  0即一样大小  -1即q大</span><br><span class="line">        return strcmp(p,q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int str_comparison_user(char *p,char *q)//这个比较函数为自己写的</span><br><span class="line">    &#123;</span><br><span class="line">        //先求出各自的长度 遍历长度最小的字符串比较,防止越界</span><br><span class="line">        //这是作者自己想到的,有什么好的想法欢迎来补充</span><br><span class="line">        //如果面试提到的话，自己可以借鉴一下</span><br><span class="line">        int lenp=str_length(p);</span><br><span class="line">        int lenq=str_length(q);</span><br><span class="line">        int theMin=lenp&gt;lenq?lenq:lenp;//求出最短的长度</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;theMin;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p[i]==q[i]) continue;</span><br><span class="line">            if(p[i]&gt;q[i]) return 1;</span><br><span class="line">            if(p[i]&lt;q[i]) return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return lenp&gt;lenq?1:0;//这里的做法是为了防止p的前面与q一致,但是p后面有字符</span><br><span class="line">        //EG：abcdefg  &gt;  abcd</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        char str1[1024]=&quot;hello world&quot;;//c语言中我们用char数组表示字符串</span><br><span class="line">        char str2[500]=&quot;hello friends&quot;;</span><br><span class="line"></span><br><span class="line">        printf(&quot;str1的长度:%d  str2的长度:%d\n&quot;,str_length(str1),</span><br><span class="line">               str_length(str2));</span><br><span class="line"></span><br><span class="line">        //测试一下sizeof的区别</span><br><span class="line">        printf(&quot;str1的空间:%d\n&quot;,sizeof(str1)/sizeof(char));//输出1024</span><br><span class="line"></span><br><span class="line">        //字符串系统和自己写的比较</span><br><span class="line">        printf(&quot;系统函数 比较结果:%d\n&quot;,str_comparison_system(str1,str2));</span><br><span class="line">        printf(&quot;自己写函数 比较结果:%d\n&quot;,str_comparison_user(str1,str2));</span><br><span class="line"></span><br><span class="line">        //小福利 送上汇编写的 memory 内存函数的使用</span><br><span class="line"></span><br><span class="line">        memset(str2,0,sizeof(str2));//内存设置  一般把数组清0用</span><br><span class="line">        /*</span><br><span class="line">        参数一是你要设置的数组首地址</span><br><span class="line">        参数二是字节填充大小  注意int是占8或4个字节全填上1的话 结果就肯定不是1了</span><br><span class="line">        参数三是你要填的字节长度</span><br><span class="line">        */</span><br><span class="line">        puts(str2);</span><br><span class="line">        </span><br><span class="line">        memcpy(str2,str1,sizeof(str2));//内存拷贝</span><br><span class="line">        // 与strcpy(str2,str1);大同小异 但实际上mem的效率是大于strcpy的</span><br><span class="line">        //参数一看就懂了  把str1拷贝给str2  但是最后的参数一定是谁短写谁，否则炸内存</span><br><span class="line"></span><br><span class="line">        puts(str2);</span><br><span class="line">        puts(str1);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c++版的string 数据类型</span><br><span class="line"></span><br><span class="line">    #include &lt;iostream&gt;</span><br><span class="line">    #include &lt;string&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line"></span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        string str1=&quot;hello world&quot;;</span><br><span class="line">        string str2=&quot;hello friends&quot;;</span><br><span class="line">        //哎 是不是有疑问了？不用考虑字串的空间大小么？</span><br><span class="line">        //这里我解释：程序运行实在操作系统的堆上运行的，线程实在栈上运行的</span><br><span class="line">        //既然实在堆上运行的，就看你电脑内存了，所以你就可以不用管了</span><br><span class="line">        //string 可以用[] 下标访问</span><br><span class="line"></span><br><span class="line">        // string 的输入两种方式  空格能输入和不能输入</span><br><span class="line"></span><br><span class="line">        //接收空格的字符串输入</span><br><span class="line">        // getline(cin,str1);//意思就是接收一行 回车生效</span><br><span class="line"></span><br><span class="line">        //不能接收空格的输入</span><br><span class="line">        // cin&gt;&gt;str1;</span><br><span class="line"></span><br><span class="line">        //求字符串的长度 string.length()</span><br><span class="line">        cout&lt;&lt;&quot;str1的长度为&quot;&lt;&lt;str1.length()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        //字符串比较 直接用 &lt;、== 或 &gt; 判断就行了</span><br><span class="line">        cout&lt;&lt;(str1&gt;str2)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        //子串</span><br><span class="line"></span><br><span class="line">        string sub=str1.substr(5,3);//从5的位置截取3个长度  wo</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;sub&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        //查找 时间效率为O(nlog(n)) 原理就是用的模式匹配</span><br><span class="line">        int flag=str1.find(&quot;lyf&quot;);//找不到返回-1 找到返回下标</span><br><span class="line">        cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        //删除 n个 和 全部</span><br><span class="line">        str1.erase(3,4);//从3的位置删除4个</span><br><span class="line">        cout&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">        str1.clear();//全部删除</span><br><span class="line">         cout&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">         //加法 连接运算符</span><br><span class="line">         cout&lt;&lt;(str1+str2)&lt;&lt;endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然字符串简单，但是在生活中的用处确实很广，就像论文查重，文章检索，没有字符串的数据结构和算法是实现不了的&lt;/p&gt;
&lt;p&gt;我在这先放上c语言版的char数组，文章的下篇将介绍c++版的（唉，这两天感觉自己特别能得吧了）。&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(三) 字符串模式匹配KMP和基于哈希的匹配</title>
    <link href="https://LTitan.github.io/2018/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8DKMP%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E7%9A%84%E5%8C%B9%E9%85%8D/"/>
    <id>https://LTitan.github.io/2018/07/16/数据结构(三) 字符串模式匹配KMP和基于哈希的匹配/</id>
    <published>2018-07-16T01:16:59.000Z</published>
    <updated>2018-09-25T09:37:00.248Z</updated>
    
    <content type="html"><![CDATA[<p>没想到吧，竟然是同一天写的，先安利一个kmp视频，看完之后你看代码就有感觉了。<br>但是还是感觉哈希流批，万物基于哈希（滑稽）</p><p>###链接 <a href="https://www.bilibili.com/video/av3246487?from=search&seid=7582725949952602806" target="_blank" rel="noopener">B站链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">    #include &lt;stdlib.h&gt;</span><br><span class="line">    #include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">    //用c++的编译器吧，这里我用到了动态内存</span><br><span class="line">    int *next;</span><br><span class="line"></span><br><span class="line">    void getNext(char* p)</span><br><span class="line">    &#123;</span><br><span class="line">        int lenp = strlen(p);</span><br><span class="line">        next[0] = -1; //第一个是未知的，就放上-1</span><br><span class="line">        int k = -1;//指针指在字符串最外面</span><br><span class="line">        int j = 0;  //指针指在首地址上</span><br><span class="line">        while (j &lt; lenp - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            //p[k]表示前缀，p[j]表示后缀</span><br><span class="line">            if (k == -1 || p[j] == p[k])</span><br><span class="line">            &#123;</span><br><span class="line">                ++k;</span><br><span class="line">                ++j;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Kmp(char* s, char* p)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = 0;</span><br><span class="line">        int lens = strlen(s);</span><br><span class="line">        int lenp = strlen(p);</span><br><span class="line">        while (i &lt; lens &amp;&amp; j &lt; lenp)</span><br><span class="line">        &#123;</span><br><span class="line">            //如果j = -1,或者当前字符匹配成功即 S[i] == P[j]，都令指针移动</span><br><span class="line">            if (j == -1 || s[i] == p[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //如果j != -1，且当前字符匹配失败，则令 i 指针不懂，j 回退</span><br><span class="line">                j = next[j];   //next[j]即为j所对应的next值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j == lenp)</span><br><span class="line">            return i - j;  //返回下标</span><br><span class="line">        else</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        char str1[1024]=&quot;helloOWorldNotheloWhy??helhellelo&quot;;</span><br><span class="line">        char str2[1024]=&quot;hellelo&quot;;</span><br><span class="line"></span><br><span class="line">        next=new int[strlen(str2)+1];//next 数组长度应该比匹配串大一</span><br><span class="line"></span><br><span class="line">        getNext(str2);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d&quot;,Kmp(str1,str2));</span><br><span class="line">        delete[] next;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">哈希匹配</span><br><span class="line"></span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    #include &lt;stdlib.h&gt;</span><br><span class="line">    #include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">    //基于哈希的模式匹配</span><br><span class="line"></span><br><span class="line">    typedef unsigned long long ULL;//用编译器最大的数据类型 2^64</span><br><span class="line"></span><br><span class="line">    const ULL HashConst=100000007;//哈希基数 mod hashConst</span><br><span class="line"></span><br><span class="line">    int hash_machting(char *a,char *b)//这次是判a是否在b中出现</span><br><span class="line">    &#123;</span><br><span class="line">        int lena=strlen(a);</span><br><span class="line">        int lenb=strlen(b);</span><br><span class="line"></span><br><span class="line">        if(lena&gt;lenb) return -1;//a太长了</span><br><span class="line"></span><br><span class="line">        ULL t=1;</span><br><span class="line">        //计算哈希计数的lena次方</span><br><span class="line">        for(int i=0;i&lt;lena;++i) t*=HashConst;</span><br><span class="line"></span><br><span class="line">        //计算a和b为lena的前缀对应的哈希值</span><br><span class="line">        ULL ah=0,bh=0;</span><br><span class="line">        for(int i=0;i&lt;lena;++i) ah=ah*HashConst+a[i];</span><br><span class="line">        for(int i=0;i&lt;lena;++i) bh=bh*HashConst+b[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //匹配 更新哈希值</span><br><span class="line">        for(int i=0;i+lena&lt;=lenb;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ah==bh) return i;</span><br><span class="line">            if(i+lena&lt;lenb) bh=bh*HashConst+b[i+lena]-b[i]*t;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        char str1[1024]=&quot;helloOWorldNotheloWhy??helhellelo&quot;;</span><br><span class="line">        char str2[1024]=&quot;hellelo&quot;;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d\n&quot;,hash_machting(str2,str1));</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;没想到吧，竟然是同一天写的，先安利一个kmp视频，看完之后你看代码就有感觉了。&lt;br&gt;
但是还是感觉哈希流批，万物基于哈希（滑稽）&lt;/p&gt;
&lt;p&gt;###链接 &lt;a href=&quot;https://www.bilibili.com/video/av3246487?from=sea
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(一)单链表、栈、和队列</title>
    <link href="https://LTitan.github.io/2018/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E5%92%8C%E9%98%9F%E5%88%97%20/"/>
    <id>https://LTitan.github.io/2018/07/15/数据结构(一)单链表、栈、和队列 /</id>
    <published>2018-07-15T04:16:59.000Z</published>
    <updated>2018-09-25T09:41:34.895Z</updated>
    
    <content type="html"><![CDATA[<p>看到实验室这么多考研的童鞋，自己觉得得去分享点东西把，把自己会的分享给他们吧。</p><p>这次只是单链表的创建、插入、删除、查找</p><p>单链表的c语言代码加详细注释，双向链表和循环链表待更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;//申请和释放内存用</span><br><span class="line"></span><br><span class="line">//前提说明 所有的i++ 用 ++i使用，i++需要额外的寄存器 ++i则反，提高运行效率</span><br><span class="line">//如有内存泄漏及溢出或者野指针情况 请及时提出</span><br><span class="line"></span><br><span class="line">//带头节点的单链表</span><br><span class="line">typedef struct _linked_list</span><br><span class="line">&#123;</span><br><span class="line">    int data;//这里只是用了一个int当作测试数据，自己可以改</span><br><span class="line">    struct _linked_list *next;//尾指针</span><br><span class="line"></span><br><span class="line">&#125;linkedList;//重新命名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void traversing(linkedList *List)//遍历链表</span><br><span class="line">&#123;</span><br><span class="line">    linkedList *p=List-&gt;next;//遍历指针p先指向list的第一个位置 而不是头节点位置</span><br><span class="line">    while(p!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,p-&gt;data);</span><br><span class="line"></span><br><span class="line">        p=p-&gt;next;//不断往下指</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);//最后换行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void create_tail(linkedList *List,const int n)//尾插法 n表示要插入的个数</span><br><span class="line">&#123;</span><br><span class="line">    linkedList *tail=List;</span><br><span class="line">    tail-&gt;next=NULL;//先将尾巴放在链表头的位置，然后才进行尾插</span><br><span class="line">    int temp;//输入值的中间变量</span><br><span class="line">    for(int i=0;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;请输入第%d节点的数值\n&quot;,i+1);</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%d&quot;,&amp;temp);//输入数值</span><br><span class="line">        linkedList *newNode=(linkedList*)malloc(sizeof(linkedList));//申请一个新的节点</span><br><span class="line">        newNode-&gt;data=temp;//数值拷贝</span><br><span class="line">        tail-&gt;next=newNode;//尾巴的下一个指向新节点</span><br><span class="line">        newNode-&gt;next=NULL;//新节点后面没有节点了</span><br><span class="line">        tail=newNode;//新节点变成尾巴</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int insert_node(linkedList *list,int pos,int data)//pos即插入位置 data即数值</span><br><span class="line">&#123;</span><br><span class="line">    //原理基本上和创建的相似</span><br><span class="line">    //因为c语言没有bool类型 只能用int类型的返回值</span><br><span class="line">    //链表的下标是从1开始的，头节点(没有数值)算0下标，自己也可以修改</span><br><span class="line"></span><br><span class="line">    if(pos&lt; 1|| list==NULL) return -1;//插入位置小于1 或者 链表为空 直接失败</span><br><span class="line">    linkedList *head=list;//先指向头节点</span><br><span class="line">    int i=0;//计数 找到插入位置的前驱</span><br><span class="line"></span><br><span class="line">    while(head!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==pos-1) break;//找到前驱结点就停止</span><br><span class="line">        ++i;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&lt;pos-1) return -1;//pos长度超过链表长度 插入失败</span><br><span class="line"></span><br><span class="line">    linkedList *newNode=(linkedList*)malloc(sizeof(linkedList));//新的节点</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line">    newNode-&gt;next=NULL;</span><br><span class="line">    linkedList *temp;//中间无意义节点</span><br><span class="line"></span><br><span class="line">    temp=head-&gt;next;</span><br><span class="line">    head-&gt;next=newNode;</span><br><span class="line">    newNode-&gt;next=temp;</span><br><span class="line">    return 1;//插入成功</span><br><span class="line">&#125;</span><br><span class="line">int select_list(linkedList *list,int x)//查找数值 返回下标数组 不仅仅查找一个数值</span><br><span class="line">&#123;</span><br><span class="line">   int i=1;</span><br><span class="line">   linkedList *p=list-&gt;next;//遍历指针指向第一个,同上</span><br><span class="line">   //计数 j为arr的长度</span><br><span class="line">   while(p!=NULL)</span><br><span class="line">   &#123;</span><br><span class="line">       if(p-&gt;data==x) return i;//找到返回下标</span><br><span class="line">       ++i;</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   //找不到返回-1</span><br><span class="line">   return -1;</span><br><span class="line">   //拓展：查找的值不可能是唯一的，可以返回下标数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int delete_list(linkedList *list,int pos)</span><br><span class="line">&#123;</span><br><span class="line">    linkedList *p=list;</span><br><span class="line">    if(pos&lt;1||list==NULL) return -1;//删除失败</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(p!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==pos-1) break;//找到前驱结点</span><br><span class="line">        ++i;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&lt;pos-1) return -1;//查找失败，越界</span><br><span class="line">    linkedList *temp=p-&gt;next;</span><br><span class="line">    p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int n=5;</span><br><span class="line">    linkedList *mylist;</span><br><span class="line">    mylist=(linkedList*)malloc(sizeof(linkedList));//先新建一个头节点</span><br><span class="line">    mylist-&gt;next=NULL;</span><br><span class="line"></span><br><span class="line">    //大部分的函数我传参都是传的链表的地址</span><br><span class="line">    create_tail(mylist,n);//新建</span><br><span class="line">    traversing(mylist);//遍历</span><br><span class="line"></span><br><span class="line">    //插入操作 位置3 数值666 自己也可以输入</span><br><span class="line">    int flag=insert_node(mylist,3,666);</span><br><span class="line">    if(flag!=-1) puts(&quot;插入成功,链表如下&quot;);</span><br><span class="line">    else puts(&quot;插入失败,链表如下&quot;);</span><br><span class="line"></span><br><span class="line">    traversing(mylist);</span><br><span class="line"></span><br><span class="line">    //查找666的位置 肯定是3 因为上边刚插入的</span><br><span class="line">    //查找能做到了 修改也是easy的</span><br><span class="line">    printf(&quot;查找的位置%d\n&quot;,select_list(mylist,666));</span><br><span class="line"></span><br><span class="line">    flag=delete_list(mylist,4);//删掉第4个</span><br><span class="line">    </span><br><span class="line">    if(flag!=-1) puts(&quot;删除成功,链表如下&quot;);</span><br><span class="line">    else puts(&quot;删除失败,链表如下&quot;);</span><br><span class="line">    traversing(mylist);</span><br><span class="line">    </span><br><span class="line">    //拓展：将遍历链表改为求链表的长度，自己把头插法补充上吧</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈： 了解了基本性质就行了，c语言版的没必要，附上c++版的栈类，及常用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//stack 为模板类 &lt;&gt; 里面用来放数据类型</span><br><span class="line">stack&lt;char&gt; mystack;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   //empty 函数使用  返回bool值 空为true</span><br><span class="line">   if(mystack.empty()) puts(&quot;栈是空的&quot;);</span><br><span class="line"></span><br><span class="line">   //push 入栈    pop 出栈  top  返回栈顶数值&lt;&gt;里面的类型</span><br><span class="line"></span><br><span class="line">   mystack.push(&apos;h&apos;);//1</span><br><span class="line">   mystack.push(&apos;e&apos;);//2</span><br><span class="line">   mystack.push(&apos;l&apos;);//3</span><br><span class="line">   mystack.push(&apos;l&apos;);//4</span><br><span class="line">   mystack.push(&apos;o&apos;);//5</span><br><span class="line"></span><br><span class="line">   while(!mystack.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       char temp=mystack.top();</span><br><span class="line">       mystack.pop();</span><br><span class="line">       printf(&quot;%c  &quot;,temp);</span><br><span class="line">   &#125;//打印 o l l e h</span><br><span class="line"></span><br><span class="line">   //size 即栈的大小 此时以及pop完毕 栈为空size为0</span><br><span class="line">   printf(&quot;\n栈的大小为%d\n&quot;,mystack.size());</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>福利：附上一个常用好玩东西 啥都能放的数组vector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;//算法头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//切记一定有 命名空间std</span><br><span class="line">//vector 为模板类 &lt;&gt; 里面用来放数据类型</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; Point;</span><br><span class="line">/*</span><br><span class="line">对组 pair &lt;type,type&gt; 能放下一对数据，常用来表示坐标啊，对应关系啊</span><br><span class="line">pair.fist 顾名思义 第一个数据嘛 pair.second 表示第二个数据</span><br><span class="line"></span><br><span class="line">pair&lt;int,int&gt; 我把它定义成新的数据类型 坐标</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; point_arr;</span><br><span class="line">/*</span><br><span class="line">先说一下构造函数 vector(int)  表示一个长为n数值全为0的数组</span><br><span class="line">啥也没有的话默认为空数组  size() 可以检测出来</span><br><span class="line">*/</span><br><span class="line">bool cmp(const Point a,const Point b);//这个先不用管，下文继续说</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //push_back  什么back？ 那有没有front？</span><br><span class="line">    //对不起 没有 在一个线性数组里面往前插入一个数的时间复杂度是O(n)</span><br><span class="line">    //插一个O（n） 插n个就是O（n^2） 效率可想而知</span><br><span class="line">    point_arr.push_back(Point(1,1));</span><br><span class="line">    point_arr.push_back(Point(1,-3));</span><br><span class="line">    point_arr.push_back(Point(2,4));</span><br><span class="line">    point_arr.push_back(Point(-12,8));</span><br><span class="line">    point_arr.push_back(Point(7,6));//在数组里面放入5个点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //我想按照y的大小从小到大 把这些点拍个序怎么排</span><br><span class="line">    //冒泡？太慢了  归并排序？自己又写不出来</span><br><span class="line">    //这时候 c++的好用之处就来了,看下一行代码 和最后一个函数</span><br><span class="line"></span><br><span class="line">    sort(point_arr.begin(),point_arr.end(),cmp);</span><br><span class="line">    //begin 就相当于首指针  end 就相当于尾指针 两个相减就是数组大小</span><br><span class="line">    //不信的话可以试试，只不过stl把指针简化了，变安全了，改叫迭代器了</span><br><span class="line">    //cmp 就是上文的注释函数 即为排序函数，这个函数可以自己写，想怎么排就怎么排</span><br><span class="line">    //就是调用了系统的 快速排序函数 sort（）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //排序完了 就得打印了，是不是得pop啊</span><br><span class="line">    //这里可以不用pop 万一这些数据还用呢，pop了就没了</span><br><span class="line">    //这里可以用运算符重载 []  直接用到下标，注意是否越界</span><br><span class="line"></span><br><span class="line">    puts(&quot;y从小到大的结果:&quot;);</span><br><span class="line">    for(unsigned int i=0;i&lt;point_arr.size();++i)</span><br><span class="line">        printf(&quot;(%d,%d)\n&quot;,point_arr[i].first,//x</span><br><span class="line">               point_arr[i].second//y</span><br><span class="line">               );</span><br><span class="line">    //上面是用[] 可不可以用指针呢？可以，不过叫做迭代器</span><br><span class="line">    //  iterator  这个类型的都叫迭代器</span><br><span class="line"></span><br><span class="line">    puts(&quot;遍历2:&quot;);</span><br><span class="line">    vector&lt;Point&gt;::iterator  itor;//创建一个迭代器对象</span><br><span class="line"></span><br><span class="line">    for(itor=point_arr.begin();itor!=point_arr.end();itor++)</span><br><span class="line">    &#123;</span><br><span class="line">        //注意指针的自增运算符 ++  就是移动指针一个位置</span><br><span class="line">        printf(&quot;(%d,%d)\n&quot;,itor-&gt;first,//x</span><br><span class="line">               itor-&gt;second//y</span><br><span class="line">               );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //自己写一个按照x排序的吧</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(const Point a,const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    //按照y的大小排序 所以只看second 就行了</span><br><span class="line">    //a b 是有顺序的 第一个参数永远在第二个前面</span><br><span class="line">    if(a.second&lt;b.second)</span><br><span class="line">        return true;//后面比前面小就是true  从小到大 简单易懂</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到实验室这么多考研的童鞋，自己觉得得去分享点东西把，把自己会的分享给他们吧。&lt;/p&gt;
&lt;p&gt;这次只是单链表的创建、插入、删除、查找&lt;/p&gt;
&lt;p&gt;单链表的c语言代码加详细注释，双向链表和循环链表待更新&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>操作系统--页面置换算法</title>
    <link href="https://LTitan.github.io/2018/06/16/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <id>https://LTitan.github.io/2018/06/16/页面置换算法/</id>
    <published>2018-06-16T02:16:59.000Z</published>
    <updated>2018-09-25T09:46:40.574Z</updated>
    
    <content type="html"><![CDATA[<p>###最佳置换算法<br>本人只是简单的列举三种算法的解题过程，但是实际问题得具体分析，感谢刘静文学姐，对缺页率的计算加已改正。</p><p>假设系统给某进程分配了三个物理块，有以下的页面号引用串：</p><p><img src="/images/2018/06/1.png" alt="alt"></p><p>则前三次装入内存并未发生中断，但是缺页，如下:</p><p><img src="/images/2018/06/2.png" alt="alt"></p><p>第四次时，在页中未发现2,发生缺页中断，根据最佳置换算法，发生一下操作：<br>即舍弃内存页中引用串下次出现的最大值</p><p><img src="/images/2018/06/3.png" alt="alt"><br>== &lt;7,0,1&gt; -&gt; &lt;2,0,1&gt; ==</p><p>第五次时0存在，不会发生缺页中断</p><p>第六次3在内存页中未找到，缺页中断发生，置换：</p><p><img src="/images/2018/06/4.png" alt="alt"><br>== &lt;2,0,1&gt; -&gt; &lt;2,0,3&gt; ==</p><p>……<br>依次类推，最后结果如下：</p><p><img src="/images/2018/06/5.png" alt="alt"></p><p>&lt;2,7,1&gt;</p><p>缺页率为：<br>前三次未发生缺页中断，但是需要调入内存，仍属于缺页范围。<br>前三次加上红框缺页次数6 总次数17 f=(6+3)/17×100%=52.9%</p><p>FIFO 算法</p><p>先进先出算法<br>还是以前的数据，有三个物理块，数据如下,且前三次不会发生缺页中断：</p><p><img src="/images/2018/06/2.png" alt="alt"></p><p>第四次时发生，缺页中断，先进先出算法：7先进的，所以7先出：</p><p><img src="/images/2018/06/6.png" alt="alt"><br>== &lt;7,0,1&gt; -&gt; &lt;2,0,1&gt; ==</p><p>第5次时未发生缺页中断<br>第六次时，3未找到，发生缺页中断，如下：</p><p><img src="/images/2018/06/7.png" alt="alt"><br>== &lt;2,0,1&gt; -&gt; &lt;2,3,1&gt; ==</p><p>依次类推，最终结果如下：</p><p><img src="/images/2018/06/8.png" alt="alt"><br>&lt;7,1,2&gt;</p><p>缺页率计算如下：<br>前三次未发生缺页中断，但是需要调入内存，仍属于缺页范围。<br>前三次加上红框缺页次数10 总次数17 f=(10+3)/17×100%=76.5%<br>这个算法比上者算法接近多一倍</p><p>##LRU算法（最近最久未使用）</p><p>还是如上数据，前三次结果未改变：<br><img src="/images/2018/06/2.png" alt="alt"></p><p>第四次时，和FIFO算法一致：</p><p><img src="/images/2018/06/9.png" alt="alt"><br>== &lt;7,0,1&gt; -&gt; &lt;2,0,1&gt; ==</p><p>第五次未改变，第六次发生缺页中断，如下，最好比较FIFO和LRU的区别：</p><p><img src="/images/2018/06/10.png" alt="alt"><br>== &lt;2,0,1&gt; -&gt; &lt;2,0,3&gt; ==</p><p>依次类推，最后结果如下：</p><p><img src="/images/2018/06/11.png" alt="alt"><br>&lt;1,7,2&gt;</p><p>缺页率计算如下：<br>前三次未发生缺页中断，但是需要调入内存，仍属于缺页范围。<br>前三次加上红框缺页次数8 总次数17 f=(8+3)/17×100%=64.7%</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###最佳置换算法&lt;br&gt;
本人只是简单的列举三种算法的解题过程，但是实际问题得具体分析，感谢刘静文学姐，对缺页率的计算加已改正。&lt;/p&gt;
&lt;p&gt;假设系统给某进程分配了三个物理块，有以下的页面号引用串：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/06/1.
      
    
    </summary>
    
    
      <category term="OS" scheme="https://LTitan.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>进程同步问题</title>
    <link href="https://LTitan.github.io/2018/06/13/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://LTitan.github.io/2018/06/13/进程同步问题/</id>
    <published>2018-06-13T02:16:59.000Z</published>
    <updated>2018-09-25T09:51:17.471Z</updated>
    
    <content type="html"><![CDATA[<p>#读写者问题(多个)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int wmutex=1,rmutex=1;//读写信号量</span><br><span class="line">   int readCount=0;//读者数量</span><br><span class="line">   void Writer();</span><br><span class="line">   void Reader();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       Reader();</span><br><span class="line">           Writer();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   //写者：</span><br><span class="line">   void Writer()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)&#123;</span><br><span class="line">   P(wmutex);</span><br><span class="line">       ...</span><br><span class="line">       写书</span><br><span class="line">       ...</span><br><span class="line">       V(wmutex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //读者</span><br><span class="line">   void Reader()</span><br><span class="line">   &#123;</span><br><span class="line">  while(1)</span><br><span class="line">       &#123;</span><br><span class="line">   P(rmutex);</span><br><span class="line">       if(readCount==0)</span><br><span class="line">       P(wmutex);</span><br><span class="line">       readCount++;</span><br><span class="line">       V(rmutex);</span><br><span class="line">       ...</span><br><span class="line">       读书</span><br><span class="line">       ...</span><br><span class="line">       P(rmutex);</span><br><span class="line">       readCount--;</span><br><span class="line">       if(readCount==0)</span><br><span class="line">       V(wmutex);</span><br><span class="line">       V(rmutex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>#哲学家就餐问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int chopstick[]=&#123;1,1,1,1,1&#125;;//五个筷子</span><br><span class="line">   int mutex=1;</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       switch(i)</span><br><span class="line">           &#123;</span><br><span class="line">       V(SB);</span><br><span class="line">           case 1~5: Pi();break;</span><br><span class="line">           &#125;</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   Pi()//第i个哲学家进餐</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(mutex);              //在取筷子前获得互斥量</span><br><span class="line">   P(chopstick[i]);       //取左边筷子</span><br><span class="line">   P(chopstick[(i+1)%5]); //取右边筷子</span><br><span class="line">   V(mutex);              //释放取筷子的信号量</span><br><span class="line">           ...</span><br><span class="line">  eat;                   //进餐</span><br><span class="line">           ...</span><br><span class="line">   V(chopstick[i]);       //放回左边筷子</span><br><span class="line">   V(chopstick[(i+1)%5]); //放回右边筷子</span><br><span class="line">           ...</span><br><span class="line">   think;//思考</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>#生产者消费者问题</p><p>== 一个生产者 一个消费者 一个缓冲器：==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int buffer;//1 表示生产 0表示消费</span><br><span class="line">   int empty=1,full=0;//空和满</span><br><span class="line">   void producer();</span><br><span class="line">   void consumer();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       producer();   consumer();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">    void producer()</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       ...</span><br><span class="line">           生产</span><br><span class="line">           ...</span><br><span class="line">       P(empty);</span><br><span class="line">           buffer=1;</span><br><span class="line">           V(full);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void consumer()</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(full);</span><br><span class="line">           buffer=0;</span><br><span class="line">           V(empty);</span><br><span class="line">           ...</span><br><span class="line">           消费</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><mark>一个生产者 一个消费者 n个缓冲器：</mark></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int buffer[1024],t=0,k=0;</span><br><span class="line">   int empty=1,full=0;</span><br><span class="line">   void producer();</span><br><span class="line">   void consumer();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       producer();   consumer();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">    void producer()</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       ...</span><br><span class="line">           生产</span><br><span class="line">           ...</span><br><span class="line">           P(empty);</span><br><span class="line">           buffer[k]=1;</span><br><span class="line">           k=(++k)%n;</span><br><span class="line">           V(full);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void consumer()</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(full);</span><br><span class="line">           buffer[t]=0;</span><br><span class="line">           t=(++t)%n;</span><br><span class="line">           V(empty);</span><br><span class="line">           ...</span><br><span class="line">           消费</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>#司机与售票员问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int s1=0,s2=0;</span><br><span class="line">   void P1();//司机</span><br><span class="line">   void P2();//售票员</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       P1();   p2();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   void P1()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)&#123;</span><br><span class="line">   P(s1);</span><br><span class="line">       ...</span><br><span class="line">       启动</span><br><span class="line">       正常行驶</span><br><span class="line">       到站</span><br><span class="line">       ...</span><br><span class="line">       V(s2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void P2()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       关门</span><br><span class="line">       V(s1);</span><br><span class="line">           售票</span><br><span class="line">           P(s2);</span><br><span class="line">           开门</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>#吃水果</p><p>问题描述<br>桌子上有一只盘子，最多可容纳两个水果，每次只能放人或取出一个水果。爸爸专向盘子中放苹果(apple)，妈妈专向盘子中放桔子(orange)，1个儿子专等吃盘子中的桔子，1个女儿专等吃盘子中的苹果。请用P、V操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">int mutex=1;</span><br><span class="line">   int empty=2;</span><br><span class="line">   int apple=0,orange=0;</span><br><span class="line">   void father(), mother();</span><br><span class="line">   void   son(),daughter();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       father(); mother();</span><br><span class="line">       son(); daughter();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   void father()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(empty);</span><br><span class="line">           P(mutex);</span><br><span class="line">           put an apple;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(apple);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void mother()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(empty);</span><br><span class="line">           P(mutex);</span><br><span class="line">           put an orange;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(orange);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void son()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(orange);</span><br><span class="line">           P(mutex);</span><br><span class="line">           eat an oeange;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(empty);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void daughter()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(apple);</span><br><span class="line">           P(mutex);</span><br><span class="line">           eat an apple;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(empty);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>#独木桥问题<br>某条河上只有一座独木桥，以便行人过河。现在河的两边都有人要过桥，按照下面的规则过桥。为了保证过桥安全，请用P、V操作分别实现正确的管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">int SA=1,SB=1,mutex=1;</span><br><span class="line">   int countA=0,countB=0;</span><br><span class="line">   void A(),B();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       A();</span><br><span class="line">       B();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   void A()</span><br><span class="line">   &#123;</span><br><span class="line">   P(SA);</span><br><span class="line">       if(countA==0)</span><br><span class="line">       &#123;</span><br><span class="line">       P(mutex);</span><br><span class="line">           countA++;</span><br><span class="line">       &#125;</span><br><span class="line">       V(SA);</span><br><span class="line">       过独木桥;</span><br><span class="line">       P(SA);</span><br><span class="line">       countA--;</span><br><span class="line">       if(countA==0)</span><br><span class="line">       &#123;</span><br><span class="line">       V(metux);</span><br><span class="line">       &#125;</span><br><span class="line">       V(SA);</span><br><span class="line">   &#125;</span><br><span class="line">   void B()</span><br><span class="line">   &#123;</span><br><span class="line">   P(SB);</span><br><span class="line">       if(countB==0)</span><br><span class="line">       &#123;</span><br><span class="line">       P(mutex);</span><br><span class="line">           countB++;</span><br><span class="line">       &#125;</span><br><span class="line">       V(SB);</span><br><span class="line">       过独木桥;</span><br><span class="line">       P(SB);</span><br><span class="line">       countB--;</span><br><span class="line">       if(countB==0)</span><br><span class="line">       &#123;</span><br><span class="line">       V(metux);</span><br><span class="line">       &#125;</span><br><span class="line">       V(SB);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#读写者问题(多个)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
      <category term="OS" scheme="https://LTitan.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 蒙太奇效果</title>
    <link href="https://LTitan.github.io/2018/06/08/OpenCV%20%E8%92%99%E5%A4%AA%E5%A5%87%E6%95%88%E6%9E%9C/"/>
    <id>https://LTitan.github.io/2018/06/08/OpenCV 蒙太奇效果/</id>
    <published>2018-06-08T03:30:22.000Z</published>
    <updated>2018-10-24T12:35:01.264Z</updated>
    
    <content type="html"><![CDATA[<p>展示一下图片的效果</p><p><em><strong>原图</strong></em></p><p><img src="/images/2018/06/change.jpeg" alt="alt"></p><p><em><strong>效果图</strong></em></p><p><img src="/images/2018/06/over.jpeg" alt="alt"></p><p><em><strong>拼接图</strong></em></p><p><img src="/images/2018/06/pin.png" alt="alt"></p><p>代码区：注释即为思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat src=imread(<span class="string">"/media/lyf/doc/蒙太奇/change.jpeg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(src.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resize(src,src,Size(),<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//长宽能放下多少张小图片</span></span><br><span class="line">    <span class="keyword">int</span> rows=src.rows,cols=src.cols;</span><br><span class="line">    <span class="keyword">int</span> much_row=rows/<span class="number">50</span>,much_col=cols/<span class="number">50</span>;</span><br><span class="line">    much_col=much_col*<span class="number">50</span>&lt;cols?much_col+<span class="number">1</span>:much_col;</span><br><span class="line">    much_row=much_row*<span class="number">50</span>&lt;rows?much_row+<span class="number">1</span>:much_row;</span><br><span class="line"></span><br><span class="line">    Mat over=Mat(much_row*<span class="number">50</span>,much_col*<span class="number">50</span>,CV_8UC3,Scalar(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    Mat micPic,temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;much_row;++i)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;much_col;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//读取拼接的图片</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> filename=<span class="string">"/media/lyf/doc/蒙太奇/m"</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss&lt;&lt;rand()%<span class="number">22</span>+<span class="number">1</span>;</span><br><span class="line">            filename+=ss.str()+<span class="string">".jpeg"</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;filename&lt;&lt;endl;</span></span><br><span class="line">            micPic=imread(filename,CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">            <span class="keyword">if</span>(micPic.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"读取过程中出现错误"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;micPic.channels()&lt;&lt;endl;</span></span><br><span class="line">            resize(micPic,micPic,Size(<span class="number">50</span>,<span class="number">50</span>));</span><br><span class="line">            temp=Mat(over,Rect(j*<span class="number">50</span>,i*<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>));</span><br><span class="line">            micPic.copyTo(temp);</span><br><span class="line">            micPic.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将图片转为 float类型的便于比例的分割</span></span><br><span class="line">    Mat src_32f,over_32f;</span><br><span class="line">    src.convertTo(src_32f,CV_32FC3);</span><br><span class="line">    over.convertTo(over_32f,CV_32FC3);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//黄金比列</span></span><br><span class="line"></span><br><span class="line">            over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">0</span>] = saturate_cast&lt;<span class="keyword">float</span>&gt;(<span class="number">0.382</span>*over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">0</span>]+<span class="number">0.618</span>*src_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">0</span>]);</span><br><span class="line">            over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">1</span>] = saturate_cast&lt;<span class="keyword">float</span>&gt;(<span class="number">0.382</span>*over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">1</span>]+<span class="number">0.618</span>*src_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">1</span>]);</span><br><span class="line">            over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">2</span>] = saturate_cast&lt;<span class="keyword">float</span>&gt;(<span class="number">0.382</span>*over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">2</span>]+<span class="number">0.618</span>*src_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转为正常图片格式 uchar</span></span><br><span class="line">    over_32f.convertTo(over,CV_8UC3);</span><br><span class="line">    over=Mat (over,Rect(<span class="number">0</span>,<span class="number">0</span>,cols,rows));</span><br><span class="line">    imshow(<span class="string">"原图"</span>,src);</span><br><span class="line">    imshow(<span class="string">"生成的"</span>,over);</span><br><span class="line">    resize(over,over,Size(),<span class="number">1.5</span>,<span class="number">1.5</span>);</span><br><span class="line">    imwrite(<span class="string">"over.jpeg"</span>,over);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;展示一下图片的效果&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;原图&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/06/change.jpeg&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/e
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>转移linux（一）qt+opencv3.3视频播放器加摄像头读取</title>
    <link href="https://LTitan.github.io/2018/06/01/%E8%BD%AC%E7%A7%BBlinux%EF%BC%88%E4%B8%80%EF%BC%89qt+opencv3.3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E5%8A%A0%E6%91%84%E5%83%8F%E5%A4%B4%E8%AF%BB%E5%8F%96/"/>
    <id>https://LTitan.github.io/2018/06/01/转移linux（一）qt+opencv3.3视频播放器加摄像头读取/</id>
    <published>2018-06-01T01:30:22.000Z</published>
    <updated>2018-10-24T12:40:07.035Z</updated>
    
    <content type="html"><![CDATA[<h4 id="windows-mfc-c-玩不了了-打算走嵌入式线路了"><a class="markdownIt-Anchor" href="#windows-mfc-c-玩不了了-打算走嵌入式线路了"></a> windows MFC c# 玩不了了 打算走嵌入式线路了</h4><p>从opencv自己编译了n天，到今天第一个qt项目，差不多两周吧，自己电脑实体机装了**deep in linux ** 和 <strong>windows</strong>双系统，所以体验体验linux编程的乐趣</p><hr><p><strong>QT cteater</strong>的设计师界面效率快的不要不要的，更何况是c++，而且还吹嘘的什么跨平台。</p><p>附上开发的设计图</p><p><img src="/images/2018/06/qt1.png" alt="alt"></p><p>软件截图:</p><p><img src="/images/2018/06/video1.png" alt="alt"></p><p>界面来讲还好吧，比mfc好看，主要视频还是用到QT自带的多线程来逐帧播放的，调试了5个小时，哈哈哈还是挺欣慰的，以后打算入手树梅派来做项目了。</p><p>就简单的附上视频的按钮以及核心代码吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::on_openFileBtn_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开视频文件按钮 有播放的视频的话会先停止</span></span><br><span class="line">    isOpenFile=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(capture.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        capture.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件类型的对话框 不需要用指针新建一个类</span></span><br><span class="line">    <span class="comment">//自行可以添加视频格式</span></span><br><span class="line">    QString FileName=QFileDialog::getOpenFileName(<span class="keyword">this</span>,tr(<span class="string">"打开文件"</span>),<span class="string">"."</span>,</span><br><span class="line">                                              tr(<span class="string">"Video Files(*.avi *.mp4 *.flv)"</span>));</span><br><span class="line">    <span class="comment">// capture.open(FileName.toLocal8Bit.data());  //防止字符串乱码转化</span></span><br><span class="line">    capture.open(FileName.toStdString());<span class="comment">//字符串(全英文目录比较好)的转化</span></span><br><span class="line">    <span class="keyword">if</span>(capture.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        rate=capture.get(CV_CAP_PROP_FPS);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(isOpenFile)</span><br><span class="line">        &#123;</span><br><span class="line">            vd_x=capture.get(CV_CAP_PROP_FRAME_COUNT);</span><br><span class="line">        ui-&gt;videoLong-&gt;setRange(<span class="number">0</span>,vd_x);</span><br><span class="line">            &#125;</span><br><span class="line">        capture&gt;&gt;frame;</span><br><span class="line">        <span class="keyword">if</span>(!frame.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//自适应窗口大小</span></span><br><span class="line">            width_x=ui-&gt;ImageLabel-&gt;width()*<span class="number">1.0</span>/frame.cols;</span><br><span class="line">            height_x=ui-&gt;ImageLabel-&gt;height()*<span class="number">1.0</span>/frame.rows;</span><br><span class="line"></span><br><span class="line">            cv::resize(frame,frame,Size(),width_x,height_x);</span><br><span class="line">        image=Mat2QImage(frame);</span><br><span class="line">        <span class="comment">//显示在label上</span></span><br><span class="line">        ui-&gt;ImageLabel-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line"></span><br><span class="line">            timer=<span class="keyword">new</span> QTimer(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//定时器线程 时间设置 相当与帧率</span></span><br><span class="line">            timer-&gt;setInterval(<span class="number">1000</span>/rate);</span><br><span class="line">            connect(timer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(nextFrame()));</span><br><span class="line"></span><br><span class="line">            timer-&gt;start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">Mat2QImage</span><span class="params">(Mat cvImg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Mat 类型转 QImage  类似与Mat转bitmap</span></span><br><span class="line">    QImage qImg;</span><br><span class="line">    <span class="comment">//判断通道个数</span></span><br><span class="line">    <span class="keyword">if</span>(cvImg.channels()==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cvtColor(cvImg,cvImg,CV_BGR2RGB);</span><br><span class="line"></span><br><span class="line">        qImg=QImage((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)(cvImg.data),</span><br><span class="line">                cvImg.cols,cvImg.rows,</span><br><span class="line">                cvImg.cols*cvImg.channels(),</span><br><span class="line">                QImage::Format_RGB888</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cvImg.channels()==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qImg=QImage((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)(cvImg.data),</span><br><span class="line">                cvImg.cols,cvImg.rows,</span><br><span class="line">                cvImg.cols*cvImg.channels(),</span><br><span class="line">                QImage::Format_Indexed8</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        qImg=QImage((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)(cvImg.data),</span><br><span class="line">                cvImg.cols,cvImg.rows,</span><br><span class="line">                cvImg.cols*cvImg.channels(),</span><br><span class="line">                QImage::Format_RGB888</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qImg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MainWindow::nextFrame()</span><br><span class="line">&#123;</span><br><span class="line">    capture&gt;&gt;frame;</span><br><span class="line">    <span class="keyword">if</span>(!frame.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调整大小</span></span><br><span class="line">        cv::resize(frame,frame,Size(),width_x,height_x);</span><br><span class="line">    image=Mat2QImage(frame);</span><br><span class="line">        ui-&gt;ImageLabel-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line">        <span class="keyword">if</span>(isOpenFile)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;videoLong-&gt;setValue((<span class="keyword">int</span>)(capture.get(CV_CAP_PROP_POS_FRAMES)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;windows-mfc-c-玩不了了-打算走嵌入式线路了&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windows-mfc-c-玩不了了-打算走嵌入式线路了&quot;&gt;&lt;/a&gt; windows MFC c# 玩不了了 打算走嵌入式线路了&lt;/
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>图论--最短路径和最小生成树</title>
    <link href="https://LTitan.github.io/2018/04/25/%E5%9B%BE%E8%AE%BA--%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://LTitan.github.io/2018/04/25/图论--最短路径和最小生成树/</id>
    <published>2018-04-25T09:30:22.000Z</published>
    <updated>2018-10-24T12:41:45.117Z</updated>
    
    <content type="html"><![CDATA[<p>######图的表示呢分为邻接矩阵和邻接链表。其主要算法层出不穷，这里主要介绍最短路径的ford和dijsktra，单源最短路径，思维可能有点局限，有什么好的想法可以联系我，代码有如雷同，不怨俺.<br>(数组d[]表示求解的各点最短路径，from表示来源点，to表示目的点，cost表示权值，e(i,j)表示从i到j的边 )</p><p>题目来源：    <a href="https://www.nowcoder.com/acm/contest/96#question" target="_blank" rel="noopener">小木乃伊到我家</a></p><p>输入描述:<br>第一行输入两个整数n和m（2&lt;=n&lt;=m&lt;=200000），分别表示有n座城市和m条路，城市编号为1~n（快递姐姐所在城市为1，AA所在城市为n）。<br>接下来m行，每行输入3个整数u,v,w（u,v&lt;=n，w&lt;=100000），分别表示城市u和城市v之间有一条长为w的路。<br>输出描述:<br>输出结果占一行，输出快递姐姐到达AA家最短需要走多远的路，如果没有路能走到AA家，则输出“qwb baka”（不用输出双引号）。</p><p>示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">4 4</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">3 4 3</span><br><span class="line">2 3 1</span><br><span class="line">输出</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="ford-算法解决"><a class="markdownIt-Anchor" href="#ford-算法解决"></a> Ford 算法解决</h4><p>递推公式呢就是 d[i]=min{d[j]+cost[i][j]}</p><p>但是这个效率比较低啊，时间O(e^2)，这个算法程序就不详解了；</p><p><img src="/images/2018/04/ford.png" alt="alt"></p><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_E 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> from,to,cost;&#125;;</span><br><span class="line">edge es[MAX_E];<span class="comment">//变 起点 终点 权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[MAX_E];<span class="comment">//最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,E;<span class="comment">//顶点数 边数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WithMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++)</span><br><span class="line">        d[i]=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">the_short_path</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//起点为s</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WithMax();</span><br><span class="line">    <span class="comment">//  fill(d,d+V,INF);</span></span><br><span class="line">    d[s]=<span class="number">0</span>;<span class="comment">//起点的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> update=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=E;i++)&#123;</span><br><span class="line">            edge e=es[i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.from]!=INF&amp;&amp;d[e.to]&gt;(d[e.from]+e.cost))</span><br><span class="line">            &#123;</span><br><span class="line">                d[e.to]=d[e.from]+e.cost;</span><br><span class="line">                update=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(update==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;V&gt;&gt;E)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start_time,end_time;</span><br><span class="line">    start_time=clock();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=E;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;es[i].from&gt;&gt;es[i].to&gt;&gt;es[i].cost;</span><br><span class="line">    the_short_path(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(d[V]==INF)  <span class="built_in">cout</span>&lt;&lt;<span class="string">"qwbbaka"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;d[V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    end_time=clock();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"运行时间: "</span>&lt;&lt;(<span class="keyword">double</span>)(end_time-start_time)/CLOCKS_PER_SEC&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####迪杰斯特拉算法</p><ul><li><p>引入(楼主可能是太特么懒了)：</p><p><img src="/images/2018/04/1-1.png" alt="alt"></p></li></ul><p>上图所示的图，求0到各个点的最短距离<br>具体原理如下，最后填充的哪个点进集合的位置，就是加上之前的最小距离</p><p><img src="/images/2018/04/2-1.png" alt="alt"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_A 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll to,cost;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(ll x,ll y)</span><br><span class="line">    &#123;</span><br><span class="line">    to=x;</span><br><span class="line">    cost=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> cost&gt;a.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ll V,E;<span class="comment">//顶点数和边数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; G[MAX_A];</span><br><span class="line">ll vis[MAX_A];</span><br><span class="line">ll d[MAX_A];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span><span class="comment">//参数为起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    fill(vis,vis+V+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    fill(d,d+V+<span class="number">1</span>,INF);</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; que;</span><br><span class="line">    que.push(node(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">    node e=que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">if</span>(vis[e.to]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[e.to]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;G[e.to].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll to=G[e.to][i].to,cost=G[e.to][i].cost;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!vis[to] &amp;&amp; d[to]&gt;d[e.to]+cost)</span><br><span class="line">        &#123;</span><br><span class="line">            d[to]=d[e.to]+cost;</span><br><span class="line">            que.push(node(to,d[to]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll f,t,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;V&gt;&gt;E)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">clock_t</span> <span class="keyword">start_t</span>,<span class="keyword">end_t</span>;</span><br><span class="line">        <span class="keyword">start_t</span>=clock();</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=V;i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;E;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;f&gt;&gt;t&gt;&gt;c;</span><br><span class="line">            G[f].push_back(node(t,c));</span><br><span class="line">            G[t].push_back(node(f,c));</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;d[V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">end_t</span>=clock();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">double</span>)(<span class="keyword">end_t</span>-<span class="keyword">start_t</span>)/CLOCKS_PER_SEC&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;######图的表示呢分为邻接矩阵和邻接链表。其主要算法层出不穷，这里主要介绍最短路径的ford和dijsktra，单源最短路径，思维可能有点局限，有什么好的想法可以联系我，代码有如雷同，不怨俺.&lt;br&gt;
(数组d[]表示求解的各点最短路径，from表示来源点，to表示目的
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>VS 自带数据库 MSSQLLocalDB 的使用方法</title>
    <link href="https://LTitan.github.io/2018/04/18/VS-%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%BA%93-MSSQLLocalDB-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://LTitan.github.io/2018/04/18/VS-自带数据库-MSSQLLocalDB-的使用方法/</id>
    <published>2018-04-18T05:30:22.000Z</published>
    <updated>2018-10-24T12:39:02.190Z</updated>
    
    <content type="html"><![CDATA[<p>话说数据库开课了，机房用的是SQL server2008 r2,微软的这个东西有点大，但是已经有vs的童鞋有福利了，因为vs自带一个MSSqlLocalDatabase ，就是一个本地链接的数据库，我这里演示的是<strong>VS2015</strong>教程，2013、2017应该都可以的。</p><hr><p>##下面开始教程</p><p>#####首先打开vs</p><p><strong>1、找到菜单栏，点击工具，找到连接SQL Server，如下图</strong></p><p><img src="/images/2018/04/1.png" alt="alt"></p><p><strong>2、然后会弹出这个窗口，选择本地，选择MsSqlLocalDB，然后连接，注意一定是windows验证才可以，如图</strong></p><p><img src="/images/2018/04/2.png" alt="alt"></p><p><strong>3、会在VS侧栏有个 SQl Server对象资源管理器，如下图，没找到这个窗口的，再看下个图</strong></p><p><img src="/images/2018/04/3.png" alt="alt"></p><p><img src="/images/2018/04/4.png" alt="alt"></p><p><strong>4、打开这个数据库，就是那个小箭头，添加新数据库，我这个例子呢是用的教材P71 的习题6，你们也可以换其他的测试</strong></p><p><img src="/images/2018/04/5.png" alt="alt"></p><p><strong>5、经常用的，起个新名字，放个路径</strong></p><p><img src="/images/2018/04/6.png" alt="alt"></p><p><img src="/images/2018/04/7.png" alt="alt"></p><p><strong>6、打开这个新建的数据库（小箭头），然后鼠标右键，新建查询</strong></p><p><img src="/images/2018/04/8.png" alt="alt"></p><p><strong>7、写你自己定义的SQL语句，然后执行脚本，最后刷新数据库，就会完成操作</strong></p><p><img src="/images/2018/04/9.png" alt="alt"></p><p><img src="/images/2018/04/10.png" alt="alt"></p><p><img src="/images/2018/04/11.png" alt="alt"></p><p><strong>8、最后给表添加数据，这里先不考虑SQL语言插入了，显示表之后，自己往上填就行了</strong></p><p><img src="/images/2018/04/12.png" alt="alt"></p><p><img src="/images/2018/04/13.png" alt="alt"></p><p>除掉了烦人的sqlserver安装，还是挺省事吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;话说数据库开课了，机房用的是SQL server2008 r2,微软的这个东西有点大，但是已经有vs的童鞋有福利了，因为vs自带一个MSSqlLocalDatabase ，就是一个本地链接的数据库，我这里演示的是&lt;strong&gt;VS2015&lt;/strong&gt;教程，2013、
      
    
    </summary>
    
    
      <category term="others" scheme="https://LTitan.github.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 帧差法运动物体追踪</title>
    <link href="https://LTitan.github.io/2018/03/28/OpenCV-%E5%B8%A7%E5%B7%AE%E6%B3%95%E8%BF%90%E5%8A%A8%E7%89%A9%E4%BD%93%E8%BF%BD%E8%B8%AA/"/>
    <id>https://LTitan.github.io/2018/03/28/OpenCV-帧差法运动物体追踪/</id>
    <published>2018-03-28T06:30:20.000Z</published>
    <updated>2018-10-24T12:32:55.870Z</updated>
    
    <content type="html"><![CDATA[<p>最近迷上了物体跟踪的玩意,于是乎找了好多视频去看，翻来覆去呢就是用到了轮廓检测的api，还有耐心的不断的调试。</p><p>原理呢是帧差法（就是一帧一帧的比较）非HSV分离<br>看看视频 软件的工作流程</p><p><video src="/images/2018/03/233.mp4" controls="controls" width="820"><br>您的浏览器不支持 video 标签。<br></video></p><p>代码呢，emmm，真的是不好理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv/cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv/highgui.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> SEAITVITV_VALUE = <span class="number">20</span>; <span class="comment">//阈值操作的起始范围 可手动调试</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> BLUR_SIZE = <span class="number">10</span>;<span class="comment">//blur 滤波Size大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> theObject[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;<span class="comment">//发现目标的坐标 x,y</span></span><br><span class="line"></span><br><span class="line">Rect objectBoundingRect = Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//目标跳动的矩形</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intTostring</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int 类型 转为 string</span></span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; num;</span><br><span class="line"><span class="keyword">return</span> ss.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchForMovement</span><span class="params">(Mat thresgoldImage, Mat &amp;cameraFeed)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">//寻找移动物</span></span><br><span class="line"></span><br><span class="line">Mat temp;</span><br><span class="line"><span class="keyword">bool</span> objectDetected;</span><br><span class="line"><span class="comment">//形参的阈值图像传给中间变量</span></span><br><span class="line">thresgoldImage.copyTo(temp);</span><br><span class="line"><span class="comment">//向量 用来存放轮廓点坐标 Point</span></span><br><span class="line"><span class="built_in">vector</span> &lt; <span class="built_in">vector</span>&lt;Point&gt; &gt; contours;</span><br><span class="line"><span class="comment">//向量 用来存放层次</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Vec4i&gt; hierarchy;</span><br><span class="line"><span class="comment">//调用api 来获取层次和轮廓点</span></span><br><span class="line">findContours(temp, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);</span><br><span class="line"><span class="comment">//判断轮廓点的个数是否为0</span></span><br><span class="line"><span class="keyword">if</span> (contours.size() &gt; <span class="number">0</span>) objectDetected = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    objectDetected = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (objectDetected)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//找最大的轮廓点</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt; &gt; largesContours;</span><br><span class="line">    largesContours.push_back(contours.at(contours.size() - <span class="number">1</span>));</span><br><span class="line">    objectBoundingRect = boundingRect(largesContours.at(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//约找出接近中心位置的点</span></span><br><span class="line">    <span class="keyword">int</span> xpos = objectBoundingRect.x + objectBoundingRect.width / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ypos = objectBoundingRect.y + objectBoundingRect.width / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//传给全局变量暂放坐标</span></span><br><span class="line">    theObject[<span class="number">0</span>] = xpos; theObject[<span class="number">1</span>] = ypos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = theObject[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> y = theObject[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//画一个圆圈</span></span><br><span class="line">circle(cameraFeed, Point(x, y), <span class="number">20</span>, Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="comment">//画十字架</span></span><br><span class="line">line(cameraFeed, Point(x, y), Point(x, y - <span class="number">25</span>),Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>);</span><br><span class="line">line(cameraFeed, Point(x, y), Point(x, y + <span class="number">25</span>), Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">line(cameraFeed, Point(x, y), Point(x<span class="number">-25</span>, y ), Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">line(cameraFeed, Point(x, y), Point(x+<span class="number">25</span>, y ), Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="comment">//输出坐标</span></span><br><span class="line">putText(cameraFeed, <span class="string">"tracking at:("</span> + intTostring(x) + <span class="string">","</span> + intTostring(y) + <span class="string">")"</span>, Point(x, y), <span class="number">1</span>, <span class="number">1</span>, Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按键是否调试</span></span><br><span class="line"><span class="keyword">bool</span> debugMode = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//按键是否跟踪</span></span><br><span class="line"><span class="keyword">bool</span> trackingEnable = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//是否暂停视频</span></span><br><span class="line"><span class="keyword">bool</span> pause = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//视频取帧的frame1 frame2</span></span><br><span class="line">Mat frame1, frame2;</span><br><span class="line"><span class="comment">//上者灰度图像</span></span><br><span class="line">Mat gray1, gray2;</span><br><span class="line"><span class="comment">//两者的不同图像</span></span><br><span class="line">Mat differenceImg;</span><br><span class="line"><span class="comment">//视频类</span></span><br><span class="line">VideoCapture capture;</span><br><span class="line"><span class="comment">//阈值后的图像</span></span><br><span class="line">Mat thres;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//不断的播放视频 进行调试</span></span><br><span class="line">&#123;</span><br><span class="line">    capture.open(<span class="string">"3.mp4"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!capture.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打开视频失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int total = capture.get(CV_CAP_PROP_FRAME_COUNT);</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; total &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//获取当前帧 与总帧进行比较 从而循环</span></span><br><span class="line">    <span class="keyword">while</span> (capture.get(CV_CAP_PROP_POS_FRAMES) &lt; capture.get(CV_CAP_PROP_FRAME_COUNT) - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//捕获frame1</span></span><br><span class="line">        capture.read(frame1);</span><br><span class="line">        <span class="comment">//转为灰度图</span></span><br><span class="line">        cvtColor(frame1, gray1, COLOR_BGR2GRAY);</span><br><span class="line">        <span class="comment">//捕获frame2</span></span><br><span class="line">        capture.read(frame2);</span><br><span class="line">        <span class="comment">//转为灰度图</span></span><br><span class="line">        cvtColor(frame2, gray2, COLOR_BGR2GRAY);</span><br><span class="line">        <span class="comment">//调用api 找出两者不同的区域 存入differenceImg</span></span><br><span class="line">        absdiff(gray1, gray2, differenceImg);</span><br><span class="line">        <span class="comment">//阈值操作</span></span><br><span class="line">        threshold(differenceImg, thres, SEAITVITV_VALUE, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">        <span class="comment">//滤波 去噪点</span></span><br><span class="line">        blur(thres, thres, Size(BLUR_SIZE, BLUR_SIZE));</span><br><span class="line">        <span class="comment">//再进行一遍阈值</span></span><br><span class="line">        threshold(thres, thres, SEAITVITV_VALUE, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">        <span class="comment">//是否进入调试模式</span></span><br><span class="line">            <span class="keyword">if</span> (debugMode == <span class="literal">true</span>) &#123;</span><br><span class="line">            imshow(<span class="string">"thres"</span>, thres);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//销毁窗口</span></span><br><span class="line">                destroyWindow(<span class="string">"thres"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否进入追踪捕获模式</span></span><br><span class="line">            <span class="keyword">if</span> (trackingEnable) &#123;</span><br><span class="line">                searchForMovement( thres, frame1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//显示原图像</span></span><br><span class="line">            imshow(<span class="string">"frame"</span>, frame1);</span><br><span class="line">        <span class="keyword">switch</span> (waitKey(<span class="number">50</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            trackingEnable = !trackingEnable;</span><br><span class="line">        <span class="keyword">if</span> (trackingEnable == <span class="literal">false</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"没有捕获"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕获开始"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            debugMode = !debugMode;</span><br><span class="line">        <span class="keyword">if</span> (debugMode == <span class="literal">false</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"调试模式退出\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"进入调试模式"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">112</span>:</span><br><span class="line">            pause = !pause;</span><br><span class="line">            <span class="keyword">if</span> (pause == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"暂停"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">while</span> (pause == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (waitKey())</span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">112</span>:</span><br><span class="line">                        pause = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"开始"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//播放完后释放类</span></span><br><span class="line">    capture.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近迷上了物体跟踪的玩意,于是乎找了好多视频去看，翻来覆去呢就是用到了轮廓检测的api，还有耐心的不断的调试。&lt;/p&gt;
&lt;p&gt;原理呢是帧差法（就是一帧一帧的比较）非HSV分离&lt;br&gt;
看看视频 软件的工作流程&lt;/p&gt;
&lt;p&gt;&lt;video src=&quot;/images/2018/
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>新年？ 当然是烟花了！！！</title>
    <link href="https://LTitan.github.io/2018/02/26/%E6%96%B0%E5%B9%B4?-%E5%BD%93%E7%84%B6%E6%98%AF%E7%83%9F%E8%8A%B1%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>https://LTitan.github.io/2018/02/26/新年?-当然是烟花了！！！/</id>
    <published>2018-02-26T03:34:20.000Z</published>
    <updated>2018-10-24T12:43:41.411Z</updated>
    
    <content type="html"><![CDATA[<p>###唉 又过年了</p><p>过年咱也送个礼物了，<a href="/images/2018/02/fire.zip">烟花绽放.exe</a>，献给你们</p><p>内容呢是在b站上跟大佬学的，还是用到了简单的easyX 绘图库</p><p>文件和源码呢，就在上传的文件里面，解压就能看到了。</p><p>我感觉就是烟花障眼法</p><p><img src="/images/2018/02/fire.png" alt="alt"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###唉 又过年了&lt;/p&gt;
&lt;p&gt;过年咱也送个礼物了，&lt;a href=&quot;/images/2018/02/fire.zip&quot;&gt;烟花绽放.exe&lt;/a&gt;，献给你们&lt;/p&gt;
&lt;p&gt;内容呢是在b站上跟大佬学的，还是用到了简单的easyX 绘图库&lt;/p&gt;
&lt;p&gt;文件和源码呢，就在上传
      
    
    </summary>
    
    
      <category term="others" scheme="https://LTitan.github.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>图的基本遍历算法 DFS and BFS</title>
    <link href="https://LTitan.github.io/2018/01/24/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95-DFS-and-BFS/"/>
    <id>https://LTitan.github.io/2018/01/24/图的基本遍历算法-DFS-and-BFS/</id>
    <published>2018-01-24T03:34:20.000Z</published>
    <updated>2018-10-24T12:45:31.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先介绍下dfs"><a class="markdownIt-Anchor" href="#先介绍下dfs"></a> 先介绍下DFS</h2><p>下面这张图呢是图的原来状态</p><p><img src="/images/2018/01/1.png" alt="alt"></p><p>这个gif呢是其深度优先遍历的过程，ppt做的，可能会失真</p><p><img src="/images/2018/01/dfs.gif" alt="alt"></p><p>遍历的思想有了，但是对于非稀疏图来讲利用图的邻接矩阵遍历效果是不是更好。<br>那么代码就来了；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">/*</span><br><span class="line">图的深度优先搜索</span><br><span class="line">数据结构中介绍需要用到栈的帮助</span><br><span class="line">这里的栈用C++ STL的stack</span><br><span class="line">*/</span><br><span class="line">using namespace std;</span><br><span class="line">#define number 5</span><br><span class="line">//定义图的邻接矩阵</span><br><span class="line">void DFS(int start);</span><br><span class="line">int map[][5]=</span><br><span class="line">&#123;</span><br><span class="line">0,1,1,0,0,</span><br><span class="line">0,0,1,0,1,</span><br><span class="line">0,0,1,0,0,</span><br><span class="line">1,1,0,0,1,</span><br><span class="line">0,0,1,0,0</span><br><span class="line">&#125;;</span><br><span class="line">//访问过的顶点</span><br><span class="line">int visited[number + 1];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//初始化数组为0，表示一个也没访问</span><br><span class="line">memset(visited, 0, sizeof(visited));</span><br><span class="line">for (int i = 1; i &lt;= number; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (visited[i] == 1)</span><br><span class="line">        continue;</span><br><span class="line">    DFS(i);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int start)</span><br><span class="line">&#123;</span><br><span class="line">stack&lt;int&gt; stk;</span><br><span class="line">//顶点入栈</span><br><span class="line">stk.push(start);</span><br><span class="line">//表示访问</span><br><span class="line">visited[start] = 1;</span><br><span class="line"></span><br><span class="line">bool IS_PUSH = false;//是否有新的顶点入栈</span><br><span class="line">while (!stk.empty())</span><br><span class="line">&#123;</span><br><span class="line">    IS_PUSH = false;</span><br><span class="line">    int p = stk.top();</span><br><span class="line">    for (int i = 1; i &lt;= number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (map[p - 1][i - 1] == 1 &amp;&amp; !visited[i])</span><br><span class="line">            //如果他俩联通，并且还没有访问过</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = 1;</span><br><span class="line">            stk.push(i);</span><br><span class="line">            IS_PUSH = true;//新顶点入栈</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!IS_PUSH)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span><br><span class="line">        stk.pop();//顶点出栈</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，看图就能看出来了，不过代码只是更简单点了</p><h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h2><p><img src="/images/2018/01/2.png" alt="alt"></p><p><img src="/images/2018/01/bfs.gif" alt="alt"></p><p>代码用到队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void BFS(int start)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">//顶点入队</span><br><span class="line">que.push(start);</span><br><span class="line">//表示访问</span><br><span class="line">visited[start] = 1;</span><br><span class="line"></span><br><span class="line">while (!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">    int p = que.front();</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span><br><span class="line">    que.pop();</span><br><span class="line">    for (int i = 1; i &lt;= number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (map[p - 1][i - 1] == 1 &amp;&amp; !visited[i])</span><br><span class="line">            //如果他俩联通，并且还没有访问过</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = 1;</span><br><span class="line">            que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;先介绍下dfs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#先介绍下dfs&quot;&gt;&lt;/a&gt; 先介绍下DFS&lt;/h2&gt;
&lt;p&gt;下面这张图呢是图的原来状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/01/1.png&quot; alt
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
</feed>
