<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LTitan`s Blog</title>
  
  <subtitle>foolish</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://LTitan.github.io/"/>
  <updated>2019-02-25T12:45:18.000Z</updated>
  <id>https://LTitan.github.io/</id>
  
  <author>
    <name>lyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>手指数字识别</title>
    <link href="https://LTitan.github.io/2019/02/25/%E6%89%8B%E6%8C%87%E6%95%B0%E5%AD%97%E8%AF%86%E5%88%AB/"/>
    <id>https://LTitan.github.io/2019/02/25/手指数字识别/</id>
    <published>2019-02-25T11:50:56.000Z</published>
    <updated>2019-02-25T12:45:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1><p>家里面闲置一台手机，手机的像素还算不错，于是就想利用手机的摄像功能代替摄像头，来收集拍摄些图片进行深度学习。</p><h2 id="设备展示"><a class="markdownIt-Anchor" href="#设备展示"></a> 设备展示</h2><p>这个手机被我用钉子固定在一块木板上了<br><img src="/images/2019/02/tools1.jpg" alt=""><br>通过droidcam软件，进行局域网视频传输<br><img src="/images/2019/02/tools2.jpg" alt=""><br><img src="/images/2019/02/tools3.png" alt=""></p><h1 id="手指数字拍摄"><a class="markdownIt-Anchor" href="#手指数字拍摄"></a> 手指数字拍摄</h1><p>捣鼓这个东西太费时间太费力了，因为一个人的工作，我一边调动作一边拍照，弄了一下午胳膊也麻了。</p><p>最后0-5个数字分别拍了60张，成果如下(之前没有截图，现在剩下我处理过的了都是100*100的照片了):<br><img src="/images/2019/02/figure.png" alt=""></p><h2 id="利用opencv浅层处理"><a class="markdownIt-Anchor" href="#利用opencv浅层处理"></a> 利用opencv浅层处理</h2><p>拍完后的照片都是640*480格式大小的，最后用opencv简单的resize成100 * 100的了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 先用代码读取改路径下的所有照片名称</span><br><span class="line">图片 = cv::imread(路径)</span><br><span class="line">cv::resize(图片,保存的图像,cv::Size(100,100))</span><br><span class="line">cv::imwrite(路径, 保存的图像)</span><br></pre></td></tr></table></figure><h1 id="模型搭建"><a class="markdownIt-Anchor" href="#模型搭建"></a> 模型搭建</h1><p>此模型采用的是自己瞎想的卷积神经网络，用了VGG的思想，但是最后结果不尽心意，抽时间改善模型<br><img src="/images/2019/02/ConvNet.jpg" alt=""></p><h1 id="模型代码及结果"><a class="markdownIt-Anchor" href="#模型代码及结果"></a> 模型代码及结果</h1><p>结果只有35%的成效，看来是模型很不行(笑哭),下次用用VGG-16试试水</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tf_utils</span><br><span class="line"><span class="keyword">import</span> MyData</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_train,y_train = MyData.load_datas()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(y_train.shape)</span><br></pre></td></tr></table></figure><pre><code>(360, 1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(shape, stddev, name)</span>:</span></span><br><span class="line">    inital = tf.truncated_normal(shape, stddev=stddev)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(inital, name=name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bais</span><span class="params">(length, value, name)</span>:</span></span><br><span class="line">    inital = tf.constant(value, shape=length)</span><br><span class="line">    <span class="keyword">return</span> tf.Variable(inital, name=name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_one_hot</span><span class="params">(Y, C)</span>:</span></span><br><span class="line">    Y = np.eye(C)[Y.reshape(<span class="number">-1</span>)]</span><br><span class="line">    <span class="keyword">return</span> Y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv2d</span><span class="params">(x, W, stride, pad)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.conv2d(x, W, strides=stride, padding=pad)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pool_2d</span><span class="params">(x, ksize, stride)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tf.nn.max_pool(x, ksize=ksize, strides= stride, padding=<span class="string">'SAME'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m, height, width, channels = X_train.shape</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X = tf.placeholder(tf.float32, [<span class="keyword">None</span>, height, width, channels], name=<span class="string">'X'</span>)</span><br><span class="line">y_true = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">6</span>], name=<span class="string">'y_true'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">conv_W_b = &#123;</span><br><span class="line">    <span class="string">'W1'</span>:weight([<span class="number">9</span>, <span class="number">9</span>, channels, <span class="number">10</span>], <span class="number">0.5</span>, <span class="string">'W1'</span>),</span><br><span class="line">    <span class="string">'b1'</span>:bais([<span class="number">10</span>], <span class="number">0.5</span>, <span class="string">'b1'</span>),</span><br><span class="line">    <span class="string">'W2'</span>:weight([<span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">16</span>], <span class="number">0.5</span>, <span class="string">'W2'</span>),</span><br><span class="line">    <span class="string">'b2'</span>:bais([<span class="number">16</span>], <span class="number">0.5</span>, <span class="string">'b2'</span>),</span><br><span class="line">    <span class="string">'W3'</span>:weight([<span class="number">7</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">32</span>], <span class="number">0.5</span>, <span class="string">'W3'</span>),</span><br><span class="line">    <span class="string">'b3'</span>:bais([<span class="number">32</span>], <span class="number">0.5</span>, <span class="string">'b3'</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h_conv1 = tf.nn.relu(conv2d(X, conv_W_b[<span class="string">'W1'</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], <span class="string">'VALID'</span>) + conv_W_b[<span class="string">'b1'</span>])</span><br><span class="line">h_pool1 = max_pool_2d(h_conv1, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h_conv2 = tf.nn.relu(conv2d(h_pool1, conv_W_b[<span class="string">'W2'</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], <span class="string">'VALID'</span>) + conv_W_b[<span class="string">'b2'</span>])</span><br><span class="line">h_pool2 = max_pool_2d(h_conv2, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h_conv3 = tf.nn.relu(conv2d(h_pool2, conv_W_b[<span class="string">'W3'</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], <span class="string">'VALID'</span>) + conv_W_b[<span class="string">'b3'</span>])</span><br><span class="line">h_pool3 = max_pool_2d(h_conv3, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fc_W_b = &#123;</span><br><span class="line">    <span class="string">'W_fc1'</span>:weight([<span class="number">7</span>*<span class="number">7</span>*<span class="number">32</span>, <span class="number">512</span>], <span class="number">0.5</span>, <span class="string">'W_fc1'</span>),</span><br><span class="line">    <span class="string">'b_fc1'</span>:bais([<span class="number">512</span>], <span class="number">0.1</span>, <span class="string">'b_fc1'</span>),</span><br><span class="line">    <span class="string">'W_fc2'</span>:weight([<span class="number">512</span>, <span class="number">512</span>], <span class="number">0.5</span>, <span class="string">'W_fc2'</span>),</span><br><span class="line">    <span class="string">'b_fc2'</span>:bais([<span class="number">512</span>], <span class="number">0.1</span>, <span class="string">'b_fc2'</span>),</span><br><span class="line">    <span class="string">'W_fc3'</span>:weight([<span class="number">512</span>,<span class="number">64</span>], <span class="number">0.5</span>, <span class="string">'W_fc3'</span>),</span><br><span class="line">    <span class="string">'b_fc3'</span>:bais([<span class="number">64</span>], <span class="number">0.1</span>, <span class="string">'b_fc3'</span>),</span><br><span class="line">    <span class="string">'W_out'</span>:weight([<span class="number">64</span>, <span class="number">6</span>], <span class="number">0.5</span>, <span class="string">'W_out'</span>),</span><br><span class="line">    <span class="string">'b_out'</span>:bais([<span class="number">6</span>], <span class="number">0.1</span>, <span class="string">'b_out'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h_flat = tf.reshape(h_pool3, [<span class="number">-1</span>, <span class="number">7</span>*<span class="number">7</span>*<span class="number">32</span>])</span><br><span class="line">h_fc1 = tf.nn.relu(tf.matmul(h_flat, fc_W_b[<span class="string">'W_fc1'</span>]) + fc_W_b[<span class="string">'b_fc1'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keep_prob = tf.placeholder(tf.float32)</span><br><span class="line">h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h_fc2 = tf.nn.relu(tf.matmul(h_fc1_drop, fc_W_b[<span class="string">'W_fc2'</span>]) + fc_W_b[<span class="string">'b_fc2'</span>])</span><br><span class="line">h_fc2_drop = tf.nn.dropout(h_fc2, keep_prob)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h_fc3 = tf.nn.relu(tf.matmul(h_fc2_drop, fc_W_b[<span class="string">'W_fc3'</span>]) + fc_W_b[<span class="string">'b_fc3'</span>])</span><br><span class="line">h_fc3_drop = tf.nn.dropout(h_fc3, keep_prob)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_out = tf.nn.softmax(tf.matmul(h_fc3_drop, fc_W_b[<span class="string">'W_out'</span>]) + fc_W_b[<span class="string">'b_out'</span>], name=<span class="string">'output'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_batch</span><span class="params">(train_data, train_target, batch_size)</span>:</span>  </span><br><span class="line">    index = [ i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(train_target)) ]  </span><br><span class="line">    np.random.shuffle(index);  </span><br><span class="line">    batch_data = []; </span><br><span class="line">    batch_target = [];  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,batch_size):  </span><br><span class="line">        batch_data.append(train_data[index[i]]);  </span><br><span class="line">        batch_target.append(train_target[index[i]])  </span><br><span class="line">    <span class="keyword">return</span> batch_data, batch_target</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=y_out, labels=y_true)</span><br><span class="line">cost = tf.reduce_mean(cross_entropy)</span><br><span class="line">optimizer = tf.train.AdamOptimizer(<span class="number">0.0008</span>).minimize(cost)</span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y_out, <span class="number">1</span>), tf.argmax(y_true, <span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y_train = convert_to_one_hot(y_train, <span class="number">6</span>)</span><br><span class="line"><span class="comment">#y_test = convert_to_one_hot(y_test, 6)</span></span><br><span class="line">X_train = X_train / <span class="number">255</span></span><br><span class="line"><span class="comment">#X_test = X_test / 255</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(tf.global_variables_initializer())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2000</span>):</span><br><span class="line">        batch_x, batch_y = next_batch(X_train, y_train, <span class="number">16</span>)</span><br><span class="line">        np.random.seed(i)</span><br><span class="line">        _, c = sess.run([optimizer, cost], feed_dict=&#123;X:batch_x, y_true:batch_y, keep_prob:<span class="number">0.5</span>&#125;)</span><br><span class="line">        <span class="keyword">if</span> (i%<span class="number">100</span> == <span class="number">0</span> <span class="keyword">or</span> i==<span class="number">1999</span>) <span class="keyword">and</span> i!=<span class="number">0</span>:</span><br><span class="line">            acc = sess.run(accuracy,feed_dict=&#123;X:batch_x, y_true:batch_y, keep_prob:<span class="number">1.0</span>&#125;)</span><br><span class="line">            print(<span class="string">'迭代%d 正确率为%f'</span> %(i+<span class="number">1</span>, acc))</span><br><span class="line">            <span class="comment"># acc = sess.run(accuracy,feed_dict=&#123;X:X_test, y_true:y_test, keep_prob:1.0&#125;)</span></span><br><span class="line">           <span class="comment"># print('测试集准确率:%f  损失率%f'%(acc, c))</span></span><br></pre></td></tr></table></figure><pre><code>迭代101 正确率为0.187500迭代201 正确率为0.375000迭代301 正确率为0.187500迭代401 正确率为0.125000迭代501 正确率为0.125000迭代601 正确率为0.312500迭代701 正确率为0.312500迭代801 正确率为0.125000迭代901 正确率为0.062500迭代1001 正确率为0.187500迭代1101 正确率为0.125000迭代1201 正确率为0.125000迭代1301 正确率为0.000000迭代1401 正确率为0.125000迭代1501 正确率为0.312500迭代1601 正确率为0.125000迭代1701 正确率为0.250000迭代1801 正确率为0.250000迭代1901 正确率为0.125000迭代2000 正确率为0.187500</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备工作&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#准备工作&quot;&gt;&lt;/a&gt; 准备工作&lt;/h1&gt;
&lt;p&gt;家里面闲置一台手机，手机的像素还算不错，于是就想利用手机的摄像功能代替摄像头，来收集拍摄些图片进行深度学习。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://LTitan.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow 使用及手写字体训练</title>
    <link href="https://LTitan.github.io/2018/12/02/tensorflow/"/>
    <id>https://LTitan.github.io/2018/12/02/tensorflow/</id>
    <published>2018-12-02T11:30:22.000Z</published>
    <updated>2018-12-02T11:53:18.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tensorflow入门"><a class="markdownIt-Anchor" href="#tensorflow入门"></a> tensorflow入门</h1><p>TensorFlow™ 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。(复制过来的)<br>中文社区链接:<a href="http://www.tensorfly.cn/" target="_blank" rel="noopener">链接</a></p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装:</h2><p>python3:<br>终端下执行: pip(或者pip3) install --upgrade tensourflow</p><h2 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势:</h2><p>我们在进行深度学习的使用往往会进行后向传播，后向传播的实质是根据神经元微分求解，而tensorflow则不用考虑微积分，只实现前向传播就能运行。</p><h1 id="fb-c-b3bc"><a class="markdownIt-Anchor" href="#fb-c-b3bc"></a> f(b, c) = (b+3)*(b+c)</h1><p>用tensorflow实现此函数（jupyter写的有输出内容）,如下:</p><h2 id="单个值测试"><a class="markdownIt-Anchor" href="#单个值测试"></a> 单个值测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf <span class="comment">#导入tf包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入数组包</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">用tensorflow 实现 f(c, b) = (b+3)*(b+c)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><pre><code>'\n用tensorflow 实现 f(c, b) = (b+3)*(b+c)\n'</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = tf.Variable(<span class="number">2.</span>, name=<span class="string">'b'</span>) <span class="comment">#定义一个2.0变量为b</span></span><br><span class="line">c = tf.Variable(<span class="number">3.</span>, name=<span class="string">'c'</span>) <span class="comment">#定义一个3.0变量为c</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不妨设中间变量 e = (b+3) ,d = (b+c) ,a= f(b, c)吧</span></span><br><span class="line">three = tf.constant(<span class="number">3.</span>, name=<span class="string">'three'</span>) <span class="comment">#定义一个常量3</span></span><br><span class="line"></span><br><span class="line">e = tf.add(b,three)</span><br><span class="line">d = tf.add(b, c)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = tf.multiply(e, d) <span class="comment">#乘法</span></span><br><span class="line">print(a) <span class="comment">#结果不是25 而是一个Tensor</span></span><br></pre></td></tr></table></figure><pre><code>Tensor(&quot;Mul:0&quot;, shape=(), dtype=float32)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#真实的运行结果如下:</span></span><br><span class="line">init_top = tf.global_variables_initializer() <span class="comment">#初始化变量</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment">#打开一个tensor会话</span></span><br><span class="line">    sess.run(init_top) <span class="comment">#顺序不能变，先运行初始化</span></span><br><span class="line">    f = sess.run(a) <span class="comment">#运行tensor a</span></span><br><span class="line">    print(f)</span><br><span class="line">    sess.close() <span class="comment">#关闭会话</span></span><br></pre></td></tr></table></figure><pre><code>25.0</code></pre><h2 id="多组值测试"><a class="markdownIt-Anchor" href="#多组值测试"></a> 多组值测试</h2><p>这时候我们用到tensorflow的容器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf <span class="comment">#导入tf包</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入数组包</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">1</span>],name=<span class="string">'b'</span>) <span class="comment">#定义一个b容器,大小可以不确定,[3,1]即为3个元素,None,为未知，来源数据大小</span></span><br><span class="line">c = tf.Variable(<span class="number">3.</span>, name=<span class="string">'c'</span>) <span class="comment">#定义一个3.0变量为c</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不妨设中间变量 e = (b+3) ,d = (b+c) ,a= f(b, c)吧</span></span><br><span class="line">three = tf.constant(<span class="number">3.</span>, name=<span class="string">'three'</span>) <span class="comment">#定义一个常量3</span></span><br><span class="line">e = tf.add(b,three)</span><br><span class="line">d = tf.add(b, c)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = tf.multiply(e, d) <span class="comment">#乘法</span></span><br><span class="line">print(a) <span class="comment">#结果不是25 而是一个Tensor</span></span><br></pre></td></tr></table></figure><pre><code>Tensor(&quot;Mul:0&quot;, shape=(?, 1), dtype=float32)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#真实的运行结果如下:</span></span><br><span class="line">b_array = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]).reshape(<span class="number">5</span>,<span class="number">1</span>) <span class="comment">#创建一个b的元素数组</span></span><br><span class="line">init_top = tf.global_variables_initializer() <span class="comment">#初始化变量</span></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    <span class="comment">#打开一个tensor会话</span></span><br><span class="line">    sess.run(init_top) <span class="comment">#顺序不能变，先运行初始化</span></span><br><span class="line">    f = sess.run(a,feed_dict=&#123;b: b_array&#125;) <span class="comment">#运行tensor a, 喂食词典 b的元素 来源于 b_array</span></span><br><span class="line">    print(f) <span class="comment">#输出必然是多组值</span></span><br><span class="line">    sess.close() <span class="comment">#关闭会话</span></span><br></pre></td></tr></table></figure><pre><code>[[16.] [25.] [36.] [49.] [64.]]</code></pre><p>好了函数介绍就到这</p><h1 id="mnist-手写字体训练"><a class="markdownIt-Anchor" href="#mnist-手写字体训练"></a> MNIST 手写字体训练</h1><p>注释解释的很清楚，推荐有基础的人去看，新手会完全看不懂的</p><p><img src="/images/2018/12/layer.jpg" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.examples.tutorials.mnist <span class="keyword">import</span> input_data</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">13.0</span>, <span class="number">11.0</span>) <span class="comment">#设置plt的大小</span></span><br><span class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></span><br><span class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mnist = input_data.read_data_sets(<span class="string">'MNIST_data/'</span>, one_hot=<span class="keyword">True</span>)  <span class="comment">#加载mnist数据集</span></span><br></pre></td></tr></table></figure><pre><code>Extracting MNIST_data/train-images-idx3-ubyte.gzExtracting MNIST_data/train-labels-idx1-ubyte.gzExtracting MNIST_data/t10k-images-idx3-ubyte.gzExtracting MNIST_data/t10k-labels-idx1-ubyte.gz</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = <span class="number">0.05</span>  <span class="comment">#学习率</span></span><br><span class="line">epochs = <span class="number">20</span> <span class="comment">#迭代大次数</span></span><br><span class="line">batch_size = <span class="number">50</span> <span class="comment">#迭代小次数，也是每次训练数据集的数据量  总次数 20*50</span></span><br><span class="line">x = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">784</span>], name=<span class="string">'x'</span>) <span class="comment">#定义变量x 原图为64*64的数据</span></span><br><span class="line">y = tf.placeholder(tf.float32, [<span class="keyword">None</span>, <span class="number">10</span>], name=<span class="string">'y'</span>) <span class="comment">#</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置了3层神经元结构  第一次为300个 第二层 200个 最后输出层 10</span></span><br><span class="line">W1 = tf.Variable(tf.random_normal([<span class="number">784</span>, <span class="number">300</span>], stddev=<span class="number">0.01</span>), name=<span class="string">'W1'</span>)</span><br><span class="line"><span class="comment">#tf的正则化表示，不了解的可以忽略下行</span></span><br><span class="line">tf.add_to_collection(<span class="string">'losses'</span>, tf.contrib.layers.l2_regularizer(<span class="number">0.005</span>)(W1))</span><br><span class="line">b1 = tf.Variable(tf.random_normal([<span class="number">300</span>]), name=<span class="string">'b1'</span>)</span><br><span class="line">W2 = tf.Variable(tf.random_normal([<span class="number">300</span>, <span class="number">200</span>], stddev=<span class="number">0.01</span>), name=<span class="string">'W2'</span>)</span><br><span class="line">tf.add_to_collection(<span class="string">'losses'</span>, tf.contrib.layers.l2_regularizer(<span class="number">0.005</span>)(W2))</span><br><span class="line">b2 = tf.Variable(tf.random_normal([<span class="number">200</span>]), name=<span class="string">'b2'</span>)</span><br><span class="line">W3 = tf.Variable(tf.random_normal([<span class="number">200</span>, <span class="number">10</span>], stddev=<span class="number">0.01</span>), name=<span class="string">'W3'</span>)</span><br><span class="line">b3 = tf.Variable(tf.random_normal([<span class="number">10</span>]), name=<span class="string">'b3'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hd_out1 = tf.add(tf.matmul(x,W1), b1)</span><br><span class="line">hd_out1 = tf.nn.relu(hd_out1) <span class="comment">#第一层的输出 用的是relu函数</span></span><br><span class="line"></span><br><span class="line">hd_out2 = tf.add(tf.matmul(hd_out1,W2), b2)</span><br><span class="line">hd_out2 = tf.nn.relu(hd_out2) <span class="comment">#第二层的输出</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_ = tf.nn.softmax(tf.add(tf.matmul(hd_out2, W3), b3)) <span class="comment">#最终输出 个数为10</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y_clipped = tf.clip_by_value(y_, <span class="number">1e-10</span>, <span class="number">0.9999999</span>) <span class="comment">#过滤</span></span><br><span class="line">cross_entropy = -tf.reduce_mean(tf.reduce_sum(y*tf.log(y_clipped)+(<span class="number">1</span>-y)*tf.log(<span class="number">1</span>-y_clipped), axis=<span class="number">1</span>)) <span class="comment">#求解交叉熵</span></span><br><span class="line">tf.add_to_collection(<span class="string">'losses'</span>, cross_entropy)</span><br><span class="line">loss = tf.add_n(tf.get_collection(<span class="string">'losses'</span>)) <span class="comment">#将交叉熵放入losses集，下面会用到</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optimizer = tf.train.GradientDescentOptimizer(learning_rate)</span><br><span class="line">train = optimizer.minimize(loss) <span class="comment">#选用梯度下降算法，来进行学习，选用losses里面的最小值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init_top = tf.global_variables_initializer()</span><br><span class="line">correct_prediction = tf.equal(tf.argmax(y, <span class="number">1</span>), tf.argmax(y_, <span class="number">1</span>))</span><br><span class="line">accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) <span class="comment">#求正确率</span></span><br><span class="line"><span class="comment">#保存模型</span></span><br><span class="line">saver = tf.train.Saver()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init_top)</span><br><span class="line">    total_batch = int(len(mnist.train.labels)/ batch_size)</span><br><span class="line">    costs = []</span><br><span class="line">    <span class="keyword">for</span> ep <span class="keyword">in</span> range(epochs):</span><br><span class="line">        avg_cost = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(total_batch):</span><br><span class="line">            batch_x, batch_y = mnist.train.next_batch(batch_size)</span><br><span class="line">            _t, c = sess.run([train, cross_entropy], feed_dict=&#123;x:batch_x, y:batch_y&#125;)</span><br><span class="line">            avg_cost += c/total_batch</span><br><span class="line">        print(<span class="string">'epoch%d,cost=%f'</span>% (ep+<span class="number">1</span>,avg_cost))</span><br><span class="line">        costs.append(avg_cost)</span><br><span class="line">    print(sess.run(accuracy, feed_dict=&#123;x: mnist.test.images, y: mnist.test.labels&#125;))</span><br><span class="line">    saver.save(sess,<span class="string">'./'</span>, global_step=epochs) <span class="comment">#保存模型</span></span><br><span class="line">    sess.close()</span><br><span class="line">    costs = np.squeeze(costs)</span><br><span class="line">    plt.plot(costs)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><pre><code>epoch1,cost=1.764043epoch2,cost=0.553732epoch3,cost=0.377033epoch4,cost=0.296909epoch5,cost=0.250849epoch6,cost=0.222690epoch7,cost=0.203826epoch8,cost=0.187270epoch9,cost=0.176289epoch10,cost=0.169246epoch11,cost=0.160853epoch12,cost=0.156802epoch13,cost=0.151215epoch14,cost=0.144273epoch15,cost=0.142850epoch16,cost=0.134713epoch17,cost=0.135944epoch18,cost=0.133344epoch19,cost=0.129857epoch20,cost=0.1268900.9725</code></pre><p><img src="/images/2018/12/view.png" alt="alt"></p><p>emmm, 蜜汁随缘调参职能到97.25%了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tensorflow入门&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tensorflow入门&quot;&gt;&lt;/a&gt; tensorflow入门&lt;/h1&gt;
&lt;p&gt;TensorFlow™ 是一个采用数据流图（data flow graphs），用于
      
    
    </summary>
    
    
      <category term="DeepLearning" scheme="https://LTitan.github.io/tags/DeepLearning/"/>
    
  </entry>
  
  <entry>
    <title>个人逆向分析</title>
    <link href="https://LTitan.github.io/2018/11/20/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>https://LTitan.github.io/2018/11/20/逆向分析/</id>
    <published>2018-11-20T09:00:22.000Z</published>
    <updated>2018-11-21T12:54:43.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>在学习生活种，我们可能会觉得学习生活日常枯燥无聊，身为计算机的学习者我们会时常问计算机到底是来干啥的，（除了做一些乘除数学运算和做一些商业网页还能干些什么？），现在我将用我第一人称的角度来分析逆向数据和某些网站的信息采集，以此来提高学习生活的兴趣，加深对计算机某领域的了解(下面的操作内容我建议可以一步一去跟着操作)。</p><h2 id="下面可能会用到的工具有"><a class="markdownIt-Anchor" href="#下面可能会用到的工具有"></a> 下面可能会用到的工具有</h2><ol><li>FireFox浏览器（或者chrome浏览器）</li><li>抓包工具（Fiddler4） <a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">下载链接</a></li><li>你熟悉的编程语言</li></ol><h2 id="谏言"><a class="markdownIt-Anchor" href="#谏言"></a> 谏言</h2><p>不要用某些工具或者耍小聪明去做一些法律不允许的行为</p><h1 id="http请求协议"><a class="markdownIt-Anchor" href="#http请求协议"></a> HTTP请求协议</h1><p>由于本人也只是凭借着经验才学习到的模糊知识，所以给你的建议是去学习一些专业的网络知识，如果我去解释阐释可能会产生一些误解，反而起到误导效果，在这里我就给大家推荐去了解http如何如何运行的，URL是什么，请求的方式有哪些以及一些常用的网络参数…可以参考别人的博客<a href="https://www.cnblogs.com/ranyonsue/p/5984001.html" target="_blank" rel="noopener">链接</a></p><h1 id="学校教务处登录分析过程"><a class="markdownIt-Anchor" href="#学校教务处登录分析过程"></a> 学校教务处登录分析过程</h1><p>大家都知道教务处查成绩啊，查课表每次都很麻烦，所以能不能用一个简单的方式去实现，（上完满满的一天课，回到寝室打开电脑，又打开了卡卡的浏览器去登教务处，心里是不是特别烦躁/偷笑）,这时候就要把我们的脑洞和编程掏出来了。</p><h2 id="fiddler的使用"><a class="markdownIt-Anchor" href="#fiddler的使用"></a> fiddler的使用</h2><p>先打开我们的fiddler软件是这样的:<br><img src="/images/2018/11/3.1.1.png" alt="alt"><br>这时候不要着急，把没用的数据按键盘Ctrl+a,再按delete键全部删掉,再打开火狐或者chrome，进行下面操作（把箭头拖到浏览器上，就能锁定抓取进程了）：<br><img src="/images/2018/11/3.1.2.png" alt="alt"><br>下面是打开网页进行浏览测试：<br><img src="/images/2018/11/3.1.3.png" alt="alt"><br>这时我们点开第一条数据，就是网页的整个http请求过程：<br><img src="/images/2018/11/3.1.4.png" alt="alt"><br>123表示步骤，你可以认真看看headers里的信息，因为下面我们会用编程去实现这个过程，其中黄框是整个请求信息，紫框是真个响应信息。</p><h2 id="登录测试"><a class="markdownIt-Anchor" href="#登录测试"></a> 登录测试</h2><p>我将会用我自己的信息登录，如下图:<br><img src="/images/2018/11/3.2.1.png" alt="alt"><br>fiddler查看整个信息:<br><img src="/images/2018/11/3.2.2.png" alt="alt"><br>发现网页跳转了？？？？很纳闷这个网页使用来干啥的，于是我们来查看这个网页发送了啥数据:<br><img src="/images/2018/11/3.2.3.png" alt="alt"><br>查看表单，结果发现了encode一个表单，然后又开始好奇了？？？是不是这个就是登录的账号和密码的加密鸭，我们接着进行分析：</p><h3 id="查看网页源码"><a class="markdownIt-Anchor" href="#查看网页源码"></a> 查看网页源码</h3><p><img src="/images/2018/11/3.2.4.png" alt="alt"><br><img src="/images/2018/11/3.2.5.png" alt="alt"><br>分析源码，找到学号和密码那两个输入框的源码，会发现标签会有id的吧，这个不用说也就懂，js可以通过id来获取用户的输入信息进行绑定:<br><img src="/images/2018/11/3.2.6.png" alt="alt"><br>然后我们往后面接着找有没有什么js程序来处理这些信息呢？<br>这时候我们有了大大的收获(我们找到了上面留下来的疑问encode):<br><img src="/images/2018/11/3.2.7.png" alt="alt"><br>源码意思呢就是先判断学号和密码是否为空，再进行了一个encodeInp函数，最后生成了一个学号+%%%+密码的字符串进行登录验证的,哈哈哈，那么登录就解决了</p><h3 id="加密和解密"><a class="markdownIt-Anchor" href="#加密和解密"></a> 加密和解密</h3><p>这是两个难兄难弟，正如你的qq登录一样，现在的进行安全认证都是得加密的，随然上面我们知道了登录字符串的由来，但是他也不是我们原来的学号啊，是一大串啊，下面我们将解密encodeInp：<br>返回到源码的最前端，我们去找js的源码:<br><img src="/images/2018/11/3.2.8.png" alt="alt"><br>点这个js链接,按Ctrl+F查找字符encodeInp(结果还真查找到了)：<br><img src="/images/2018/11/3.2.9.png" alt="alt"><br>这个js源码大家可能啃不动，所以我也不卖关子了，在这里我就直接说好了，源码的内容就是Base64加密，对比如下:<br><img src="/images/2018/11/3.2.10.png" alt="alt"><br>你会神奇的发现我的学号机密后和encode前部分是一模一样的，所以加密也告一段落</p><h2 id="编程实现"><a class="markdownIt-Anchor" href="#编程实现"></a> 编程实现</h2><p>上面呢我们分析了教务处的后台原来是用encode验证登录的，那么登录后不是一个302网页吗，又不是教务处登进去的首界面，那么分析又来了，现在大部分的网站后台是根据登录后给你一个cookie信息，后台在验证的时候会一直用当前用户的cookie信息是否合法来验证，验证不过去就访问不了界面，（哈哈，这是我凭借经验得出来的，其他的验证我还没怎么留意，欢迎补充）。所以教务处的整体架构呢，就是用302网页来获取cookie信息，再转到别的网页去让学生浏览。cookie如下：<br><img src="/images/2018/11/3.3.1.png" alt="alt"><br>好了，下面就用python进行登录一下测试:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#用python的bease64库来进行加密编码</span><br><span class="line">import base64</span><br><span class="line">#用requests模块来进行请求处理</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">student_number = input(&apos;输入学号:\n&apos;)</span><br><span class="line">student_password = input(&apos;输入密码\n&apos;)</span><br><span class="line"></span><br><span class="line">#base64编码后的学号  输入的信息转为utf-8</span><br><span class="line">code_stuNumber = base64.b64encode(student_number.encode(&apos;utf-8&apos;))</span><br><span class="line">code_password = base64.b64encode(student_password.encode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line">login_url = &quot;http://cdjwc.ccu.edu.cn/jsxsd/xk/LoginToXk&quot; #登录的url，就是302的那个网址</span><br><span class="line">index_url = &quot;http://cdjwc.ccu.edu.cn/jsxsd/framework/xsMain.jsp&quot; #学生的首界面</span><br><span class="line"></span><br><span class="line">#为了方便保存cookie信息，我们这里用requests的session就是全局用一个会话来模拟浏览器访问，就不要额外去保存cookie了</span><br><span class="line">session = requests.session()</span><br><span class="line">#首部信息，标志的操作系统和浏览器的信息</span><br><span class="line">header = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0&apos;&#125;</span><br><span class="line">#提交信息就是我们分析的 encode字符串</span><br><span class="line">post_data = &#123;&apos;encoded&apos;:code_stuNumber+b&quot;%%%&quot;+code_password&#125;</span><br><span class="line"></span><br><span class="line">#登录</span><br><span class="line">try:</span><br><span class="line">    re =session.post(login_url, headers = header, data=post_data) #进行post请求，加上我们的首部和encode</span><br><span class="line">except:</span><br><span class="line">    print(&apos;出错&apos;)</span><br><span class="line">    exit(-1)</span><br><span class="line">#打印一下状态码</span><br><span class="line">print(&quot;登录状态&quot;+str(re.status_code))</span><br><span class="line"></span><br><span class="line">#首页查看</span><br><span class="line">try:</span><br><span class="line">    re = session.get(index_url, headers=header)</span><br><span class="line">except:</span><br><span class="line">    print(&apos;出错&apos;)</span><br><span class="line">    exit(-1)</span><br><span class="line">#打印一下你的网页源码，查看是否有你的名字,有就是模拟成功了</span><br><span class="line">print(re.text)</span><br></pre></td></tr></table></figure><p><img src="/images/2018/11/3.3.2.png" alt="alt"><br><img src="/images/2018/11/3.3.3.png" alt="alt"></p><p>PS:(暂时先更新教务处的，有时间就更新别的网站测试)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h1&gt;
&lt;p&gt;在学习生活种，我们可能会觉得学习生活日常枯燥无聊，身为计算机的学习者我们会时常问计算机到底是来干啥的，（除了做一些乘除数学运算和做一些商业网页还
      
    
    </summary>
    
    
      <category term="other" scheme="https://LTitan.github.io/tags/other/"/>
    
  </entry>
  
  <entry>
    <title>基于ORB的图像矫正</title>
    <link href="https://LTitan.github.io/2018/07/25/%E5%9F%BA%E4%BA%8Eorb%E7%9A%84%E5%9B%BE%E5%83%8F%E7%9F%AB%E6%AD%A3/"/>
    <id>https://LTitan.github.io/2018/07/25/基于orb的图像矫正/</id>
    <published>2018-07-25T04:30:22.000Z</published>
    <updated>2018-10-25T02:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单应性矩阵"><a class="markdownIt-Anchor" href="#单应性矩阵"></a> 单应性矩阵</h1><p>在二维平面上，平面的单应性被定义为从一个平面到另一个平面的投影映射，就像我们拍一张照片时，从我们眼前的点一一映射到摄像机内部一样。英文学名叫做homography（单应性，ps:下面的鲁棒性就是稳定性。</p><p>下即为一个简单的3x3homo矩阵</p><p class="katex-block katex-error" title="ParseError: KaTeX parse error: Expected &amp; or \\ or \end at position 39: …00 &amp; h01 &amp; h02 \̲̲h10 &amp; h11 &amp; h12…">\left[\begin{matrix}h00 &amp; h01 &amp; h02 \h10 &amp; h11 &amp; h12 \h20 &amp; h21 &amp; h22\end{matrix}\right] \tag{1}</p><p>其平面坐标变换对应为(原坐标为(x1,y1),其变换为(x2,y2)):</p><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>1</mn></msub><mtext> </mtext><msub><mi>y</mi><mn>1</mn></msub><mtext> </mtext><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mi>H</mi><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>2</mn></msub><mtext> </mtext><msub><mi>y</mi><mn>2</mn></msub><mtext> </mtext><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>0</mn><mn>0</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>0</mn><mn>1</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>0</mn><mn>2</mn></mrow><mtext> </mtext><mi>h</mi><mrow><mn>1</mn><mn>0</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>1</mn><mn>1</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>1</mn><mn>2</mn></mrow><mtext> </mtext><mi>h</mi><mrow><mn>2</mn><mn>0</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>h</mi><mrow><mn>2</mn><mn>1</mn></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>h</mi><mrow><mn>2</mn><mn>2</mn></mrow></msub></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>x</mi><mn>2</mn></msub><mtext> </mtext><msub><mi>y</mi><mn>2</mn></msub><mtext> </mtext><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\left[\begin{array}{c}x_1 \ y_1 \ 1\end{array}\right] = H \left[\begin{array}{c}x_2 \ y_2 \ 1\end{array}\right] = \left[\begin{array}{ccc}h{00} &amp; h{01} &amp; h{02} \ h{10} &amp; h{11} &amp; h{12} \ h{20} &amp; h{21} &amp; h_{22} \end{array} \right] \left[ \begin{array}{c} x_2 \ y_2 \ 1 \end{array}\right]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.8500000000000001em;"></span><span class="strut bottom" style="height:1.20001em;vertical-align:-0.35001em;"></span><span class="base"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mord rule" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">0</span><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">0</span><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">0</span><span class="mord">2</span></span><span class="mspace"> </span><span class="mord mathit">h</span><span class="mord"><span class="mord">1</span><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">1</span><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">1</span><span class="mord">2</span></span><span class="mspace"> </span><span class="mord mathit">h</span><span class="mord"><span class="mord">2</span><span class="mord">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathit">h</span><span class="mord"><span class="mord">2</span><span class="mord">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span><span class="mord rule" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathit">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mspace"> </span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span></span></p><p>下图为变换的例子</p><p><img src="https://www.learnopencv.com/wp-content/uploads/2016/01/homography-example.jpg" alt="alt"></p><p>在OpenCV里面，单应矩阵的计算函数为 :</p><p>Mat findHomography(inputArray points1,inputArray points2,int method)</p><p>. 参数一为输入的x1，y1 点集</p><p>. 参数二为输入的 x2，y2 点集</p><p>. 参数三为计算方法：0 - 使用所有点的常规方法 RANSAC - 基于RANSAC的鲁棒方法 LMEDS - 最小中值稳健方法 RHO - 基于PROSAC的鲁棒方法</p><p>#关键点检测</p><p>上篇里有介绍基于ORB的关键点检测，舒服的是这个算法是至今最好最快的算法，其他的检测算法还有SURF，SIFT，etc….算法，效率而讲，500点一下还是差不多的，但是点越多的话ORB绝对胜出。</p><p>#关键点匹配<br>上篇的文章依然用着老的api，但是编译了最新的3.4之后api又发生了变化(mmp)，这次能直接detect 和compute一起用了。</p><p>其用到头文件 xfeatures2d/nonfree.hpp</p><p>命名空间 cv::xfeatures2d</p><p>检测器创建如下，只能处理灰度图像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ptr&lt;Feature2D&gt; orb = ORB::create(MAX_FEATURES);//智能指针传参为最大检测点数</span><br></pre></td></tr></table></figure><p><img src="/images/2018/07/match2.jpg" alt=""></p><p>图像矫正如下:</p><p><img src="/images/2018/07/change.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include &lt;opencv2/xfeatures2d/nonfree.hpp&gt;</span><br><span class="line">#include &lt;opencv2/features2d.hpp&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">using namespace  cv;</span><br><span class="line">using namespace cv::xfeatures2d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const int MAX_FEATURES = 500;</span><br><span class="line">const float GOOD_MATCH_PERCENT = 0.15f;</span><br><span class="line"></span><br><span class="line">void alignImage(Mat&amp; img1, Mat&amp; img2, Mat&amp; dst, Mat h)</span><br><span class="line">&#123;</span><br><span class="line">Mat img1Gray, img2Gray;//灰度图</span><br><span class="line">cvtColor(img1, img1Gray, COLOR_BGR2GRAY);</span><br><span class="line">cvtColor(img2, img2Gray, COLOR_BGR2GRAY);//灰度处理</span><br><span class="line"></span><br><span class="line">vector&lt;KeyPoint&gt; keypoints1, keypoints2;//图1 关键点 图2 关键点</span><br><span class="line">Mat descriptors1, descriptors2;</span><br><span class="line">Ptr&lt;Feature2D&gt; orb = ORB::create(MAX_FEATURES);</span><br><span class="line"></span><br><span class="line">orb-&gt;detectAndCompute(img1Gray, Mat(), keypoints1, descriptors1);//检测匹配</span><br><span class="line"></span><br><span class="line">orb-&gt;detectAndCompute(img2Gray, Mat(), keypoints2, descriptors2);//检测匹配</span><br><span class="line"></span><br><span class="line">vector&lt;DMatch&gt; matches;</span><br><span class="line">Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::create(&quot;BruteForce-Hamming&quot;);</span><br><span class="line"></span><br><span class="line">matcher-&gt;match(descriptors1, descriptors2, matches, Mat());//匹配描线</span><br><span class="line"></span><br><span class="line">sort(matches.begin(), matches.end());//排序筛选优好的点</span><br><span class="line"></span><br><span class="line">const int numGoodMatches = matches.size()*GOOD_MATCH_PERCENT;</span><br><span class="line"></span><br><span class="line">matches.erase(matches.begin() + numGoodMatches, matches.end());</span><br><span class="line"></span><br><span class="line">Mat imMatches;</span><br><span class="line"></span><br><span class="line">drawMatches(img1, keypoints1, img2, keypoints2, matches, imMatches);</span><br><span class="line">imshow(&quot;match&quot;, imMatches);</span><br><span class="line">imwrite(&quot;F:\\match.jpg&quot;, imMatches);</span><br><span class="line">vector&lt;Point2f&gt; points1, points2;</span><br><span class="line">for (auto x : matches)</span><br><span class="line">&#123;</span><br><span class="line">points1.push_back(keypoints1[x.queryIdx].pt);</span><br><span class="line">points2.push_back(keypoints2[x.trainIdx].pt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h = findHomography(points1, points2, RANSAC);</span><br><span class="line">warpPerspective(img1, dst, h, img2.size());//旋转矫正</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int  main()</span><br><span class="line">&#123;</span><br><span class="line">string refFilename=&quot;F:\\picture\\src.jpg&quot;;//原图路径</span><br><span class="line"></span><br><span class="line">Mat src = imread(refFilename);</span><br><span class="line">string scanFilename = &quot;F:\\picture\\scanned.jpg&quot;;//扫描的或者电子版的图</span><br><span class="line">Mat scan_src = imread(scanFilename);</span><br><span class="line"></span><br><span class="line">Mat imageRege, homo;//完成图像 和 homo矩阵</span><br><span class="line">alignImage(src, scan_src, imageRege, homo);</span><br><span class="line">cout &lt;&lt; homo &lt;&lt; endl;</span><br><span class="line">imshow(&quot;dst&quot;, imageRege);</span><br><span class="line">imwrite(&quot;F:\\change.jpg&quot;, imageRege);</span><br><span class="line">waitKey();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单应性矩阵&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#单应性矩阵&quot;&gt;&lt;/a&gt; 单应性矩阵&lt;/h1&gt;
&lt;p&gt;在二维平面上，平面的单应性被定义为从一个平面到另一个平面的投影映射，就像我们拍一张照片时，从我们眼前的点一一映射到摄像机内部一
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>opencv:基于ORB特征点匹配及图像拼接</title>
    <link href="https://LTitan.github.io/2018/07/21/opencv-%E5%9F%BA%E4%BA%8EORB%E7%89%B9%E5%BE%81%E7%82%B9%E5%8C%B9%E9%85%8D%E5%8F%8A%E5%9B%BE%E5%83%8F%E6%8B%BC%E6%8E%A5/"/>
    <id>https://LTitan.github.io/2018/07/21/opencv-基于ORB特征点匹配及图像拼接/</id>
    <published>2018-07-21T02:18:59.000Z</published>
    <updated>2018-09-25T09:25:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>#ORB简述<br>ORB（Oriented FAST and Rotated BRIEF）是一种快速特征点提取和描述的算法。ORB算法分为两部分，分别是特征点提取和特征点描述。特征提取是由FAST（Features from Accelerated Segment Test）算法发展来的，特征点描述是根据BRIEF（Binary Robust IndependentElementary Features）特征描述算法改进的。ORB特征是将FAST特征点的检测方法与BRIEF特征描述子结合起来，并在它们原来的基础上做了改进与优化。</p><p>下图是我在高数课本上进行的测试:</p><p><img src="/images/2018/07/ORB.jpg" alt="alt"></p><p>#特征点匹配</p><p>例子里采集了3000个点吧对比一下，opencv3.3以后好像用上了智能指针Ptr对象，对象的创建只能用ptr模板创建，大概是因为图像再处理的过程中防止异常错误正常抛出吧。<br>两张原图：</p><p><img src="/images/2018/07/yy.jpg" alt="alt"><br><img src="/images/2018/07/zz.jpg" alt="alt"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Mat image_src1,image_src2;</span><br><span class="line">   Mat image_gray1,image_gray2;</span><br><span class="line">   image_src1=imread(&quot;D:\\yy.jpg&quot;);</span><br><span class="line">   cvtColor(image_src1,image_gray1,COLOR_BGR2GRAY);//转为灰度图</span><br><span class="line">   image_src2=imread(&quot;D:\\zz.jpg&quot;);</span><br><span class="line">   cvtColor(image_src2,image_gray2,COLOR_BGR2GRAY);//转为灰度图</span><br><span class="line"></span><br><span class="line">   Ptr&lt;Feature2D&gt; oDetectors=ORB::create(3000);//创建orb对象，采集特征点</span><br><span class="line">   vector&lt;KeyPoint&gt; KeyPoints1,KeyPoints2;//关键点数组</span><br><span class="line"></span><br><span class="line">   oDetectors-&gt;detect(image_gray1,KeyPoints1);//采集左图特征点</span><br><span class="line">   oDetectors-&gt;detect(image_gray2,KeyPoints2);//采集右图特征点</span><br><span class="line"></span><br><span class="line">   Mat imageDec1,imageDec2;</span><br><span class="line">   Ptr&lt;Feature2D&gt; ptor=ORB::create();//创建一个新的oeb对象，当然也可以用上面那个</span><br><span class="line">   ptor-&gt;compute(image_gray1,KeyPoints1,imageDec1);//描述特征点</span><br><span class="line">   ptor-&gt;compute(image_gray2,KeyPoints2,imageDec2);//描述特征点</span><br><span class="line"></span><br><span class="line">   flann::Index flannIndex(imageDec1,LshIndexParams(12,20,2),</span><br><span class="line">                           cvflann::FLANN_DIST_HAMMING);</span><br><span class="line"></span><br><span class="line">   vector&lt;DMatch&gt; goodMatchPoints;</span><br><span class="line">   Mat matchIndex(imageDec2.rows,2,CV_32SC1);</span><br><span class="line">   Mat matchDistance(imageDec2.rows,2,CV_32FC1);</span><br><span class="line"></span><br><span class="line">   flannIndex.knnSearch(imageDec2,matchIndex,matchDistance,2,flann::SearchParams());//采用k近似值 将匹配的索引和距离计算出来</span><br><span class="line"></span><br><span class="line">   for(int i=0;i &lt; matchDistance.rows;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       float t=matchDistance.at&lt;float&gt;(i,0);</span><br><span class="line">       float s=matchDistance.at&lt;float&gt;(i,1);</span><br><span class="line">       if(t&lt;s*0.46)//相似度大约为0.46就算相符</span><br><span class="line">       &#123;</span><br><span class="line">           DMatch part_matches(i,matchIndex.at&lt;int&gt;(i,0),t);</span><br><span class="line">           goodMatchPoints.push_back(part_matches);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   Mat first_matching;</span><br><span class="line">   drawMatches(image_src2,KeyPoints2,image_src1,KeyPoints1,</span><br><span class="line">               goodMatchPoints,first_matching);</span><br><span class="line">   imshow(&quot;Match&quot;,first_matching);</span><br></pre></td></tr></table></figure><p>如图，匹配完成:<br><img src="/images/2018/07/match.jpg" alt="alt"></p><p>#拼接<br>记录相似点，将另一图像适度旋转调整，然后拼接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Point2f&gt; Conners(4);// 左上角 左下角 右上角 右下角</span><br><span class="line"></span><br><span class="line">void calcCorners(const Mat&amp; homo,const Mat&amp; input)</span><br><span class="line">&#123;</span><br><span class="line">    double v2[]=&#123;0,0,1&#125;;</span><br><span class="line">    double v1[3];//改变后值</span><br><span class="line">    Mat V2=Mat(3,1,CV_64FC1,v2);</span><br><span class="line">    Mat V1=Mat(3,1,CV_64FC1,v1);</span><br><span class="line">    //下面都是重复代码计算看懂一个即可</span><br><span class="line">    V1=homo*V2;</span><br><span class="line">    Conners[0].x=v1[0]/v1[2];</span><br><span class="line">    Conners[0].y=v1[1]/v1[2];</span><br><span class="line"></span><br><span class="line">    v2[0]=0;</span><br><span class="line">    v2[1]=input.rows;</span><br><span class="line">    v2[2]=1;</span><br><span class="line">    V2=Mat(3,1,CV_64FC1,v2);</span><br><span class="line">    V1=Mat(3,1,CV_64FC1,v1);</span><br><span class="line">    V1=homo*V2;</span><br><span class="line">    Conners[1].x=v1[0]/v1[2];</span><br><span class="line">    Conners[1].y=v1[1]/v1[2];</span><br><span class="line"></span><br><span class="line">    v2[0]=input.cols;</span><br><span class="line">    v2[1]=0;</span><br><span class="line">    v2[2]=1;</span><br><span class="line">    V2=Mat(3,1,CV_64FC1,v2);</span><br><span class="line">    V1=Mat(3,1,CV_64FC1,v1);</span><br><span class="line">    V1=homo*V2;</span><br><span class="line">    Conners[2].x=v1[0]/v1[2];</span><br><span class="line">    Conners[2].y=v1[1]/v1[2];</span><br><span class="line"></span><br><span class="line">    v2[0]=input.cols;</span><br><span class="line">    v2[1]=input.rows;</span><br><span class="line">    v2[2]=1;</span><br><span class="line">    V2=Mat(3,1,CV_64FC1,v2);</span><br><span class="line">    V1=Mat(3,1,CV_64FC1,v1);</span><br><span class="line">    V1=homo*V2;</span><br><span class="line">    Conners[3].x=v1[0]/v1[2];</span><br><span class="line">    Conners[3].y=v1[1]/v1[2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main:://此处接着标题二的代码</span><br><span class="line"></span><br><span class="line">vector&lt;Point2f&gt; image_points1,image_points2;</span><br><span class="line"></span><br><span class="line">    for(auto x:goodMatchPoints)</span><br><span class="line">    &#123;</span><br><span class="line">        image_points2.push_back(KeyPoints2[x.queryIdx].pt);</span><br><span class="line">        image_points1.push_back(KeyPoints1[x.trainIdx].pt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat homo=findHomography(image_points1,image_points2,CV_RANSAC);</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;&quot;homo matrix:&quot;&lt;&lt;homo&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    calcCorners(homo,image_src1);</span><br><span class="line">    Mat imageTransform1,imageTransform2;</span><br><span class="line">    warpPerspective(image_src1,imageTransform1,homo,Size(max(Conners[2].x,</span><br><span class="line">                    Conners[3].x),image_src2.rows));</span><br><span class="line">    imshow(&quot;12&quot;,imageTransform1);</span><br><span class="line"></span><br><span class="line">    int dst_width=imageTransform1.cols;</span><br><span class="line">    int dst_height=image_src2.rows;</span><br><span class="line"></span><br><span class="line">    Mat dst(dst_height,dst_width,CV_8UC3);</span><br><span class="line">    dst.setTo(0);</span><br><span class="line">    imageTransform1.copyTo(dst(Rect(0,0,imageTransform1.cols,imageTransform1.rows)));</span><br><span class="line"></span><br><span class="line">    image_src2.copyTo(dst(Rect(0,0,image_src2.cols,image_src2.rows)));</span><br><span class="line">    imshow(&quot;pin&quot;,dst);</span><br></pre></td></tr></table></figure><p>拼接完，如图：<br><img src="/images/2018/07/pin.jpg" alt="alt"></p><p>#优化拼接处<br>此处是借鉴别人的，因为自己也不可能凭空想到，哈哈，修复拼接处的线条问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void optimizated(Mat &amp;src,Mat &amp;trans,Mat &amp;dst)</span><br><span class="line">&#123;</span><br><span class="line">    int start=min(Conners[0].x,Conners[1].x);</span><br><span class="line">    double processWidth=src.cols-start;</span><br><span class="line"></span><br><span class="line">    int rows=dst.rows;</span><br><span class="line">    int cols=src.cols;</span><br><span class="line">    double alpha=1;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;rows;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar *p=src.ptr&lt;uchar&gt;(i);</span><br><span class="line">        uchar *t=trans.ptr&lt;uchar&gt;(i);</span><br><span class="line">        uchar *d=dst.ptr&lt;uchar&gt;(i);</span><br><span class="line">        for(int j=start;j&lt;cols;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            int k=j*3;</span><br><span class="line">            if(t[k]==0&amp;&amp;t[k+1]==0&amp;&amp;t[k+2]==0) alpha=1;</span><br><span class="line">            else alpha=(processWidth-j+start)/processWidth;</span><br><span class="line"></span><br><span class="line">            d[k]=p[k]*alpha+t[k]*(1-alpha);</span><br><span class="line">            d[k+1]=p[k+1]*alpha+t[k+1]*(1-alpha);</span><br><span class="line">            d[k+2]=p[k+2]*alpha+t[k+2]*(1-alpha);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成品图效果如下:</p><p><img src="/images/2018/07/over.jpg" alt="alt"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#ORB简述&lt;br&gt;
ORB（Oriented FAST and Rotated BRIEF）是一种快速特征点提取和描述的算法。ORB算法分为两部分，分别是特征点提取和特征点描述。特征提取是由FAST（Features from Accelerated Segment Te
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(四) 双向循环链表</title>
    <link href="https://LTitan.github.io/2018/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E5%9B%9B)%20%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%20/"/>
    <id>https://LTitan.github.io/2018/07/16/数据结构(四) 双向循环链表 /</id>
    <published>2018-07-16T05:16:59.000Z</published>
    <updated>2018-10-25T01:59:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>又来安利福利了，双向和循环一起了吧，单讲双向没意思，结合在一起就有意思了，看完了第一篇的单链表应该看双向很轻松了。</p><p>运行截图</p><p><img src="/images/2018/07/dl.png" alt="alt"></p><p>遗憾没有放上查找，请自己加上吧，正序找逆序找都是easy的</p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">//双向循环链表  基本操作和单链表差不多，只不过他有自己的回头路了</span><br><span class="line"></span><br><span class="line">typedef struct _double_linked_list</span><br><span class="line">&#123;</span><br><span class="line">    int data;//存放数据</span><br><span class="line">     struct _double_linked_list *front;//前指针</span><br><span class="line">     struct _double_linked_list *next;//后指针</span><br><span class="line"></span><br><span class="line">&#125;DouLinkedList;</span><br><span class="line"></span><br><span class="line">void traversing_postive(DouLinkedList *list)//正序遍历从头到尾</span><br><span class="line">&#123;</span><br><span class="line">   DouLinkedList *p=list-&gt;next;</span><br><span class="line">   DouLinkedList *head=list;//起始头位置</span><br><span class="line">   while(p!=head)//循环到头部就停止</span><br><span class="line">   &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void traversing_reverse(DouLinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">        DouLinkedList *p=list-&gt;front;</span><br><span class="line">        DouLinkedList *head=list;</span><br><span class="line">        while(p!=head)//循环到头部就停止</span><br><span class="line">        &#123;</span><br><span class="line">             printf(&quot;%d  &quot;,p-&gt;data);</span><br><span class="line">             p=p-&gt;front;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void create_tail(DouLinkedList *list,const int n)//n还是创建的长度</span><br><span class="line">&#123;</span><br><span class="line">        DouLinkedList *p=list;</span><br><span class="line">        DouLinkedList *head=list;</span><br><span class="line">        p-&gt;front=NULL;</span><br><span class="line">        p-&gt;next=NULL;</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            DouLinkedList *temp; int data;</span><br><span class="line">            temp=(DouLinkedList*)malloc(sizeof(DouLinkedList));</span><br><span class="line">            printf(&quot;请输入第%d个结点的数据\n&quot;,i+1);</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;data);</span><br><span class="line">            temp-&gt;data=data;</span><br><span class="line"></span><br><span class="line">            head-&gt;front=temp;//头的前面指向插入的尾部</span><br><span class="line">            temp-&gt;next=head;//尾的下一个指向头部  这样就构成循环链表了</span><br><span class="line">            p-&gt;next=temp;</span><br><span class="line">            temp-&gt;front=p;</span><br><span class="line">            p=temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int insert_node(DouLinkedList *list,int pos,int data)</span><br><span class="line">&#123;</span><br><span class="line">        //链表的下标从1开始</span><br><span class="line">        if(pos&lt;1||list==NULL) return -1;//位置小于或者链表是空的 插入失败</span><br><span class="line"></span><br><span class="line">        DouLinkedList *head=list;</span><br><span class="line">        DouLinkedList *p=list-&gt;next;</span><br><span class="line"></span><br><span class="line">        int i=1;//计数i</span><br><span class="line">        while(p!=head)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==pos) break;//找到前驱点就停止</span><br><span class="line">            ++i;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;pos) return -1;//越界</span><br><span class="line">        DouLinkedList *newNode=(DouLinkedList*)malloc(sizeof(DouLinkedList));</span><br><span class="line">        newNode-&gt;data=data;</span><br><span class="line">        newNode-&gt;front=p-&gt;front;</span><br><span class="line">        p-&gt;front-&gt;next=newNode;</span><br><span class="line">        newNode-&gt;next=p;</span><br><span class="line">        p-&gt;front=newNode;</span><br><span class="line"></span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int delete_node(DouLinkedList *list,int pos)</span><br><span class="line">    &#123;</span><br><span class="line">        if(pos&lt;1||list==NULL) return -1;</span><br><span class="line"></span><br><span class="line">        DouLinkedList *p=list-&gt;next;</span><br><span class="line">        DouLinkedList *head=list;</span><br><span class="line">        int i=1;</span><br><span class="line">        while(p!=head)</span><br><span class="line">        &#123;</span><br><span class="line">            if(i==pos) break;</span><br><span class="line">            ++i;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&lt;pos) return -1;</span><br><span class="line">        p-&gt;front-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;front=p-&gt;front;</span><br><span class="line">        free(p);</span><br><span class="line">        return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        DouLinkedList *mylist;</span><br><span class="line">        mylist=(DouLinkedList*)malloc(sizeof(DouLinkedList));//新建一个头节点</span><br><span class="line"></span><br><span class="line">        create_tail(mylist,5);</span><br><span class="line">        printf(&quot;正序遍历&quot;);</span><br><span class="line">        traversing_postive(mylist);</span><br><span class="line">        printf(&quot;逆序遍历&quot;);</span><br><span class="line">        traversing_reverse(mylist);</span><br><span class="line"></span><br><span class="line">        int flag=insert_node(mylist,2,666);//在第二个插入666</span><br><span class="line"></span><br><span class="line">        if(flag!=-1) puts(&quot;插入成功&quot;);</span><br><span class="line">        else puts(&quot;插入失败&quot;);</span><br><span class="line">        traversing_postive(mylist);</span><br><span class="line"></span><br><span class="line">        flag=delete_node(mylist,3);//删除第三个</span><br><span class="line">        if(flag!=-1) puts(&quot;删除成功&quot;);</span><br><span class="line">        else puts(&quot;删除失败&quot;);</span><br><span class="line">        traversing_postive(mylist);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;又来安利福利了，双向和循环一起了吧，单讲双向没意思，结合在一起就有意思了，看完了第一篇的单链表应该看双向很轻松了。&lt;/p&gt;
&lt;p&gt;运行截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/07/dl.png&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;
&lt;p&gt;遗憾没有放上查找
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(二) 字符串的常规使用</title>
    <link href="https://LTitan.github.io/2018/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E8%A7%84%E4%BD%BF%E7%94%A8%20/"/>
    <id>https://LTitan.github.io/2018/07/16/数据结构(二) 字符串的常规使用 /</id>
    <published>2018-07-16T01:44:59.000Z</published>
    <updated>2018-09-25T09:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然字符串简单，但是在生活中的用处确实很广，就像论文查重，文章检索，没有字符串的数据结构和算法是实现不了的</p><p>我在这先放上c语言版的char数组，文章的下篇将介绍c++版的（唉，这两天感觉自己特别能得吧了）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    #include &lt;stdlib.h&gt;</span><br><span class="line">    #include &lt;string.h&gt;</span><br><span class="line">    #include &lt;memory.h&gt;</span><br><span class="line"></span><br><span class="line">    //简单点说字符串就是字符数组</span><br><span class="line">    //基本运算无非就是长度 比较 回文 模式匹配(查找)</span><br><span class="line">    //模式匹配和回文我将会单独开文章的,请耐心等等吧 = =</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //1.求字符串的长度  这里用到strlen函数</span><br><span class="line">    //那为什么不用sizeof(str)/sizeof(char) 计算呢？</span><br><span class="line">    //原因是开辟了1024个长度不一定用满，用sizeof计算呢即为1024,而非字符串长度</span><br><span class="line">    int str_length(char *s)</span><br><span class="line">    &#123;</span><br><span class="line">        return strlen(s);//直接用strlen求解</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //2.字符串比较 就是挨个比较字符串的字符</span><br><span class="line">    //可以用strcmp函数比较  也可以自己手写一个</span><br><span class="line">    int str_comparison_system(char *p,char *q)//函数意思为调用系统函数</span><br><span class="line">    &#123;</span><br><span class="line">        //返回1 即p大  0即一样大小  -1即q大</span><br><span class="line">        return strcmp(p,q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int str_comparison_user(char *p,char *q)//这个比较函数为自己写的</span><br><span class="line">    &#123;</span><br><span class="line">        //先求出各自的长度 遍历长度最小的字符串比较,防止越界</span><br><span class="line">        //这是作者自己想到的,有什么好的想法欢迎来补充</span><br><span class="line">        //如果面试提到的话，自己可以借鉴一下</span><br><span class="line">        int lenp=str_length(p);</span><br><span class="line">        int lenq=str_length(q);</span><br><span class="line">        int theMin=lenp&gt;lenq?lenq:lenp;//求出最短的长度</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;theMin;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(p[i]==q[i]) continue;</span><br><span class="line">            if(p[i]&gt;q[i]) return 1;</span><br><span class="line">            if(p[i]&lt;q[i]) return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return lenp&gt;lenq?1:0;//这里的做法是为了防止p的前面与q一致,但是p后面有字符</span><br><span class="line">        //EG：abcdefg  &gt;  abcd</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        char str1[1024]=&quot;hello world&quot;;//c语言中我们用char数组表示字符串</span><br><span class="line">        char str2[500]=&quot;hello friends&quot;;</span><br><span class="line"></span><br><span class="line">        printf(&quot;str1的长度:%d  str2的长度:%d\n&quot;,str_length(str1),</span><br><span class="line">               str_length(str2));</span><br><span class="line"></span><br><span class="line">        //测试一下sizeof的区别</span><br><span class="line">        printf(&quot;str1的空间:%d\n&quot;,sizeof(str1)/sizeof(char));//输出1024</span><br><span class="line"></span><br><span class="line">        //字符串系统和自己写的比较</span><br><span class="line">        printf(&quot;系统函数 比较结果:%d\n&quot;,str_comparison_system(str1,str2));</span><br><span class="line">        printf(&quot;自己写函数 比较结果:%d\n&quot;,str_comparison_user(str1,str2));</span><br><span class="line"></span><br><span class="line">        //小福利 送上汇编写的 memory 内存函数的使用</span><br><span class="line"></span><br><span class="line">        memset(str2,0,sizeof(str2));//内存设置  一般把数组清0用</span><br><span class="line">        /*</span><br><span class="line">        参数一是你要设置的数组首地址</span><br><span class="line">        参数二是字节填充大小  注意int是占8或4个字节全填上1的话 结果就肯定不是1了</span><br><span class="line">        参数三是你要填的字节长度</span><br><span class="line">        */</span><br><span class="line">        puts(str2);</span><br><span class="line">        </span><br><span class="line">        memcpy(str2,str1,sizeof(str2));//内存拷贝</span><br><span class="line">        // 与strcpy(str2,str1);大同小异 但实际上mem的效率是大于strcpy的</span><br><span class="line">        //参数一看就懂了  把str1拷贝给str2  但是最后的参数一定是谁短写谁，否则炸内存</span><br><span class="line"></span><br><span class="line">        puts(str2);</span><br><span class="line">        puts(str1);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c++版的string 数据类型</span><br><span class="line"></span><br><span class="line">    #include &lt;iostream&gt;</span><br><span class="line">    #include &lt;string&gt;</span><br><span class="line">    using namespace std;</span><br><span class="line"></span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        string str1=&quot;hello world&quot;;</span><br><span class="line">        string str2=&quot;hello friends&quot;;</span><br><span class="line">        //哎 是不是有疑问了？不用考虑字串的空间大小么？</span><br><span class="line">        //这里我解释：程序运行实在操作系统的堆上运行的，线程实在栈上运行的</span><br><span class="line">        //既然实在堆上运行的，就看你电脑内存了，所以你就可以不用管了</span><br><span class="line">        //string 可以用[] 下标访问</span><br><span class="line"></span><br><span class="line">        // string 的输入两种方式  空格能输入和不能输入</span><br><span class="line"></span><br><span class="line">        //接收空格的字符串输入</span><br><span class="line">        // getline(cin,str1);//意思就是接收一行 回车生效</span><br><span class="line"></span><br><span class="line">        //不能接收空格的输入</span><br><span class="line">        // cin&gt;&gt;str1;</span><br><span class="line"></span><br><span class="line">        //求字符串的长度 string.length()</span><br><span class="line">        cout&lt;&lt;&quot;str1的长度为&quot;&lt;&lt;str1.length()&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        //字符串比较 直接用 &lt;、== 或 &gt; 判断就行了</span><br><span class="line">        cout&lt;&lt;(str1&gt;str2)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        //子串</span><br><span class="line"></span><br><span class="line">        string sub=str1.substr(5,3);//从5的位置截取3个长度  wo</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;sub&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        //查找 时间效率为O(nlog(n)) 原理就是用的模式匹配</span><br><span class="line">        int flag=str1.find(&quot;lyf&quot;);//找不到返回-1 找到返回下标</span><br><span class="line">        cout&lt;&lt;flag&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        //删除 n个 和 全部</span><br><span class="line">        str1.erase(3,4);//从3的位置删除4个</span><br><span class="line">        cout&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line">        str1.clear();//全部删除</span><br><span class="line">         cout&lt;&lt;str1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">         //加法 连接运算符</span><br><span class="line">         cout&lt;&lt;(str1+str2)&lt;&lt;endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然字符串简单，但是在生活中的用处确实很广，就像论文查重，文章检索，没有字符串的数据结构和算法是实现不了的&lt;/p&gt;
&lt;p&gt;我在这先放上c语言版的char数组，文章的下篇将介绍c++版的（唉，这两天感觉自己特别能得吧了）。&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(三) 字符串模式匹配KMP和基于哈希的匹配</title>
    <link href="https://LTitan.github.io/2018/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8DKMP%E5%92%8C%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E7%9A%84%E5%8C%B9%E9%85%8D/"/>
    <id>https://LTitan.github.io/2018/07/16/数据结构(三) 字符串模式匹配KMP和基于哈希的匹配/</id>
    <published>2018-07-16T01:16:59.000Z</published>
    <updated>2018-09-25T09:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>没想到吧，竟然是同一天写的，先安利一个kmp视频，看完之后你看代码就有感觉了。<br>但是还是感觉哈希流批，万物基于哈希（滑稽）</p><p>###链接 <a href="https://www.bilibili.com/video/av3246487?from=search&seid=7582725949952602806" target="_blank" rel="noopener">B站链接</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">    #include &lt;stdlib.h&gt;</span><br><span class="line">    #include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">    //用c++的编译器吧，这里我用到了动态内存</span><br><span class="line">    int *next;</span><br><span class="line"></span><br><span class="line">    void getNext(char* p)</span><br><span class="line">    &#123;</span><br><span class="line">        int lenp = strlen(p);</span><br><span class="line">        next[0] = -1; //第一个是未知的，就放上-1</span><br><span class="line">        int k = -1;//指针指在字符串最外面</span><br><span class="line">        int j = 0;  //指针指在首地址上</span><br><span class="line">        while (j &lt; lenp - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            //p[k]表示前缀，p[j]表示后缀</span><br><span class="line">            if (k == -1 || p[j] == p[k])</span><br><span class="line">            &#123;</span><br><span class="line">                ++k;</span><br><span class="line">                ++j;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int Kmp(char* s, char* p)</span><br><span class="line">    &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = 0;</span><br><span class="line">        int lens = strlen(s);</span><br><span class="line">        int lenp = strlen(p);</span><br><span class="line">        while (i &lt; lens &amp;&amp; j &lt; lenp)</span><br><span class="line">        &#123;</span><br><span class="line">            //如果j = -1,或者当前字符匹配成功即 S[i] == P[j]，都令指针移动</span><br><span class="line">            if (j == -1 || s[i] == p[j])</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                //如果j != -1，且当前字符匹配失败，则令 i 指针不懂，j 回退</span><br><span class="line">                j = next[j];   //next[j]即为j所对应的next值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (j == lenp)</span><br><span class="line">            return i - j;  //返回下标</span><br><span class="line">        else</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        char str1[1024]=&quot;helloOWorldNotheloWhy??helhellelo&quot;;</span><br><span class="line">        char str2[1024]=&quot;hellelo&quot;;</span><br><span class="line"></span><br><span class="line">        next=new int[strlen(str2)+1];//next 数组长度应该比匹配串大一</span><br><span class="line"></span><br><span class="line">        getNext(str2);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d&quot;,Kmp(str1,str2));</span><br><span class="line">        delete[] next;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">哈希匹配</span><br><span class="line"></span><br><span class="line">    #include &lt;stdio.h&gt;</span><br><span class="line">    #include &lt;stdlib.h&gt;</span><br><span class="line">    #include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">    //基于哈希的模式匹配</span><br><span class="line"></span><br><span class="line">    typedef unsigned long long ULL;//用编译器最大的数据类型 2^64</span><br><span class="line"></span><br><span class="line">    const ULL HashConst=100000007;//哈希基数 mod hashConst</span><br><span class="line"></span><br><span class="line">    int hash_machting(char *a,char *b)//这次是判a是否在b中出现</span><br><span class="line">    &#123;</span><br><span class="line">        int lena=strlen(a);</span><br><span class="line">        int lenb=strlen(b);</span><br><span class="line"></span><br><span class="line">        if(lena&gt;lenb) return -1;//a太长了</span><br><span class="line"></span><br><span class="line">        ULL t=1;</span><br><span class="line">        //计算哈希计数的lena次方</span><br><span class="line">        for(int i=0;i&lt;lena;++i) t*=HashConst;</span><br><span class="line"></span><br><span class="line">        //计算a和b为lena的前缀对应的哈希值</span><br><span class="line">        ULL ah=0,bh=0;</span><br><span class="line">        for(int i=0;i&lt;lena;++i) ah=ah*HashConst+a[i];</span><br><span class="line">        for(int i=0;i&lt;lena;++i) bh=bh*HashConst+b[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //匹配 更新哈希值</span><br><span class="line">        for(int i=0;i+lena&lt;=lenb;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(ah==bh) return i;</span><br><span class="line">            if(i+lena&lt;lenb) bh=bh*HashConst+b[i+lena]-b[i]*t;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int main()</span><br><span class="line">    &#123;</span><br><span class="line">        char str1[1024]=&quot;helloOWorldNotheloWhy??helhellelo&quot;;</span><br><span class="line">        char str2[1024]=&quot;hellelo&quot;;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d\n&quot;,hash_machting(str2,str1));</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;没想到吧，竟然是同一天写的，先安利一个kmp视频，看完之后你看代码就有感觉了。&lt;br&gt;
但是还是感觉哈希流批，万物基于哈希（滑稽）&lt;/p&gt;
&lt;p&gt;###链接 &lt;a href=&quot;https://www.bilibili.com/video/av3246487?from=sea
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>数据结构(一)单链表、栈、和队列</title>
    <link href="https://LTitan.github.io/2018/07/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%81%E6%A0%88%E3%80%81%E5%92%8C%E9%98%9F%E5%88%97%20/"/>
    <id>https://LTitan.github.io/2018/07/15/数据结构(一)单链表、栈、和队列 /</id>
    <published>2018-07-15T04:16:59.000Z</published>
    <updated>2018-09-25T09:41:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到实验室这么多考研的童鞋，自己觉得得去分享点东西把，把自己会的分享给他们吧。</p><p>这次只是单链表的创建、插入、删除、查找</p><p>单链表的c语言代码加详细注释，双向链表和循环链表待更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;malloc.h&gt;//申请和释放内存用</span><br><span class="line"></span><br><span class="line">//前提说明 所有的i++ 用 ++i使用，i++需要额外的寄存器 ++i则反，提高运行效率</span><br><span class="line">//如有内存泄漏及溢出或者野指针情况 请及时提出</span><br><span class="line"></span><br><span class="line">//带头节点的单链表</span><br><span class="line">typedef struct _linked_list</span><br><span class="line">&#123;</span><br><span class="line">    int data;//这里只是用了一个int当作测试数据，自己可以改</span><br><span class="line">    struct _linked_list *next;//尾指针</span><br><span class="line"></span><br><span class="line">&#125;linkedList;//重新命名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void traversing(linkedList *List)//遍历链表</span><br><span class="line">&#123;</span><br><span class="line">    linkedList *p=List-&gt;next;//遍历指针p先指向list的第一个位置 而不是头节点位置</span><br><span class="line">    while(p!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;,p-&gt;data);</span><br><span class="line"></span><br><span class="line">        p=p-&gt;next;//不断往下指</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);//最后换行</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void create_tail(linkedList *List,const int n)//尾插法 n表示要插入的个数</span><br><span class="line">&#123;</span><br><span class="line">    linkedList *tail=List;</span><br><span class="line">    tail-&gt;next=NULL;//先将尾巴放在链表头的位置，然后才进行尾插</span><br><span class="line">    int temp;//输入值的中间变量</span><br><span class="line">    for(int i=0;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;请输入第%d节点的数值\n&quot;,i+1);</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%d&quot;,&amp;temp);//输入数值</span><br><span class="line">        linkedList *newNode=(linkedList*)malloc(sizeof(linkedList));//申请一个新的节点</span><br><span class="line">        newNode-&gt;data=temp;//数值拷贝</span><br><span class="line">        tail-&gt;next=newNode;//尾巴的下一个指向新节点</span><br><span class="line">        newNode-&gt;next=NULL;//新节点后面没有节点了</span><br><span class="line">        tail=newNode;//新节点变成尾巴</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int insert_node(linkedList *list,int pos,int data)//pos即插入位置 data即数值</span><br><span class="line">&#123;</span><br><span class="line">    //原理基本上和创建的相似</span><br><span class="line">    //因为c语言没有bool类型 只能用int类型的返回值</span><br><span class="line">    //链表的下标是从1开始的，头节点(没有数值)算0下标，自己也可以修改</span><br><span class="line"></span><br><span class="line">    if(pos&lt; 1|| list==NULL) return -1;//插入位置小于1 或者 链表为空 直接失败</span><br><span class="line">    linkedList *head=list;//先指向头节点</span><br><span class="line">    int i=0;//计数 找到插入位置的前驱</span><br><span class="line"></span><br><span class="line">    while(head!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==pos-1) break;//找到前驱结点就停止</span><br><span class="line">        ++i;</span><br><span class="line">        head=head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&lt;pos-1) return -1;//pos长度超过链表长度 插入失败</span><br><span class="line"></span><br><span class="line">    linkedList *newNode=(linkedList*)malloc(sizeof(linkedList));//新的节点</span><br><span class="line"></span><br><span class="line">    newNode-&gt;data=data;</span><br><span class="line">    newNode-&gt;next=NULL;</span><br><span class="line">    linkedList *temp;//中间无意义节点</span><br><span class="line"></span><br><span class="line">    temp=head-&gt;next;</span><br><span class="line">    head-&gt;next=newNode;</span><br><span class="line">    newNode-&gt;next=temp;</span><br><span class="line">    return 1;//插入成功</span><br><span class="line">&#125;</span><br><span class="line">int select_list(linkedList *list,int x)//查找数值 返回下标数组 不仅仅查找一个数值</span><br><span class="line">&#123;</span><br><span class="line">   int i=1;</span><br><span class="line">   linkedList *p=list-&gt;next;//遍历指针指向第一个,同上</span><br><span class="line">   //计数 j为arr的长度</span><br><span class="line">   while(p!=NULL)</span><br><span class="line">   &#123;</span><br><span class="line">       if(p-&gt;data==x) return i;//找到返回下标</span><br><span class="line">       ++i;</span><br><span class="line">       p=p-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   //找不到返回-1</span><br><span class="line">   return -1;</span><br><span class="line">   //拓展：查找的值不可能是唯一的，可以返回下标数组</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int delete_list(linkedList *list,int pos)</span><br><span class="line">&#123;</span><br><span class="line">    linkedList *p=list;</span><br><span class="line">    if(pos&lt;1||list==NULL) return -1;//删除失败</span><br><span class="line"></span><br><span class="line">    int i=0;</span><br><span class="line">    while(p!=NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==pos-1) break;//找到前驱结点</span><br><span class="line">        ++i;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&lt;pos-1) return -1;//查找失败，越界</span><br><span class="line">    linkedList *temp=p-&gt;next;</span><br><span class="line">    p-&gt;next=p-&gt;next-&gt;next;</span><br><span class="line">    free(temp);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    const int n=5;</span><br><span class="line">    linkedList *mylist;</span><br><span class="line">    mylist=(linkedList*)malloc(sizeof(linkedList));//先新建一个头节点</span><br><span class="line">    mylist-&gt;next=NULL;</span><br><span class="line"></span><br><span class="line">    //大部分的函数我传参都是传的链表的地址</span><br><span class="line">    create_tail(mylist,n);//新建</span><br><span class="line">    traversing(mylist);//遍历</span><br><span class="line"></span><br><span class="line">    //插入操作 位置3 数值666 自己也可以输入</span><br><span class="line">    int flag=insert_node(mylist,3,666);</span><br><span class="line">    if(flag!=-1) puts(&quot;插入成功,链表如下&quot;);</span><br><span class="line">    else puts(&quot;插入失败,链表如下&quot;);</span><br><span class="line"></span><br><span class="line">    traversing(mylist);</span><br><span class="line"></span><br><span class="line">    //查找666的位置 肯定是3 因为上边刚插入的</span><br><span class="line">    //查找能做到了 修改也是easy的</span><br><span class="line">    printf(&quot;查找的位置%d\n&quot;,select_list(mylist,666));</span><br><span class="line"></span><br><span class="line">    flag=delete_list(mylist,4);//删掉第4个</span><br><span class="line">    </span><br><span class="line">    if(flag!=-1) puts(&quot;删除成功,链表如下&quot;);</span><br><span class="line">    else puts(&quot;删除失败,链表如下&quot;);</span><br><span class="line">    traversing(mylist);</span><br><span class="line">    </span><br><span class="line">    //拓展：将遍历链表改为求链表的长度，自己把头插法补充上吧</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈： 了解了基本性质就行了，c语言版的没必要，附上c++版的栈类，及常用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//stack 为模板类 &lt;&gt; 里面用来放数据类型</span><br><span class="line">stack&lt;char&gt; mystack;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">   //empty 函数使用  返回bool值 空为true</span><br><span class="line">   if(mystack.empty()) puts(&quot;栈是空的&quot;);</span><br><span class="line"></span><br><span class="line">   //push 入栈    pop 出栈  top  返回栈顶数值&lt;&gt;里面的类型</span><br><span class="line"></span><br><span class="line">   mystack.push(&apos;h&apos;);//1</span><br><span class="line">   mystack.push(&apos;e&apos;);//2</span><br><span class="line">   mystack.push(&apos;l&apos;);//3</span><br><span class="line">   mystack.push(&apos;l&apos;);//4</span><br><span class="line">   mystack.push(&apos;o&apos;);//5</span><br><span class="line"></span><br><span class="line">   while(!mystack.empty())</span><br><span class="line">   &#123;</span><br><span class="line">       char temp=mystack.top();</span><br><span class="line">       mystack.pop();</span><br><span class="line">       printf(&quot;%c  &quot;,temp);</span><br><span class="line">   &#125;//打印 o l l e h</span><br><span class="line"></span><br><span class="line">   //size 即栈的大小 此时以及pop完毕 栈为空size为0</span><br><span class="line">   printf(&quot;\n栈的大小为%d\n&quot;,mystack.size());</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>福利：附上一个常用好玩东西 啥都能放的数组vector</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;//算法头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//切记一定有 命名空间std</span><br><span class="line">//vector 为模板类 &lt;&gt; 里面用来放数据类型</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; Point;</span><br><span class="line">/*</span><br><span class="line">对组 pair &lt;type,type&gt; 能放下一对数据，常用来表示坐标啊，对应关系啊</span><br><span class="line">pair.fist 顾名思义 第一个数据嘛 pair.second 表示第二个数据</span><br><span class="line"></span><br><span class="line">pair&lt;int,int&gt; 我把它定义成新的数据类型 坐标</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">vector&lt;Point&gt; point_arr;</span><br><span class="line">/*</span><br><span class="line">先说一下构造函数 vector(int)  表示一个长为n数值全为0的数组</span><br><span class="line">啥也没有的话默认为空数组  size() 可以检测出来</span><br><span class="line">*/</span><br><span class="line">bool cmp(const Point a,const Point b);//这个先不用管，下文继续说</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    //push_back  什么back？ 那有没有front？</span><br><span class="line">    //对不起 没有 在一个线性数组里面往前插入一个数的时间复杂度是O(n)</span><br><span class="line">    //插一个O（n） 插n个就是O（n^2） 效率可想而知</span><br><span class="line">    point_arr.push_back(Point(1,1));</span><br><span class="line">    point_arr.push_back(Point(1,-3));</span><br><span class="line">    point_arr.push_back(Point(2,4));</span><br><span class="line">    point_arr.push_back(Point(-12,8));</span><br><span class="line">    point_arr.push_back(Point(7,6));//在数组里面放入5个点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //我想按照y的大小从小到大 把这些点拍个序怎么排</span><br><span class="line">    //冒泡？太慢了  归并排序？自己又写不出来</span><br><span class="line">    //这时候 c++的好用之处就来了,看下一行代码 和最后一个函数</span><br><span class="line"></span><br><span class="line">    sort(point_arr.begin(),point_arr.end(),cmp);</span><br><span class="line">    //begin 就相当于首指针  end 就相当于尾指针 两个相减就是数组大小</span><br><span class="line">    //不信的话可以试试，只不过stl把指针简化了，变安全了，改叫迭代器了</span><br><span class="line">    //cmp 就是上文的注释函数 即为排序函数，这个函数可以自己写，想怎么排就怎么排</span><br><span class="line">    //就是调用了系统的 快速排序函数 sort（）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //排序完了 就得打印了，是不是得pop啊</span><br><span class="line">    //这里可以不用pop 万一这些数据还用呢，pop了就没了</span><br><span class="line">    //这里可以用运算符重载 []  直接用到下标，注意是否越界</span><br><span class="line"></span><br><span class="line">    puts(&quot;y从小到大的结果:&quot;);</span><br><span class="line">    for(unsigned int i=0;i&lt;point_arr.size();++i)</span><br><span class="line">        printf(&quot;(%d,%d)\n&quot;,point_arr[i].first,//x</span><br><span class="line">               point_arr[i].second//y</span><br><span class="line">               );</span><br><span class="line">    //上面是用[] 可不可以用指针呢？可以，不过叫做迭代器</span><br><span class="line">    //  iterator  这个类型的都叫迭代器</span><br><span class="line"></span><br><span class="line">    puts(&quot;遍历2:&quot;);</span><br><span class="line">    vector&lt;Point&gt;::iterator  itor;//创建一个迭代器对象</span><br><span class="line"></span><br><span class="line">    for(itor=point_arr.begin();itor!=point_arr.end();itor++)</span><br><span class="line">    &#123;</span><br><span class="line">        //注意指针的自增运算符 ++  就是移动指针一个位置</span><br><span class="line">        printf(&quot;(%d,%d)\n&quot;,itor-&gt;first,//x</span><br><span class="line">               itor-&gt;second//y</span><br><span class="line">               );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //自己写一个按照x排序的吧</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp(const Point a,const Point b)</span><br><span class="line">&#123;</span><br><span class="line">    //按照y的大小排序 所以只看second 就行了</span><br><span class="line">    //a b 是有顺序的 第一个参数永远在第二个前面</span><br><span class="line">    if(a.second&lt;b.second)</span><br><span class="line">        return true;//后面比前面小就是true  从小到大 简单易懂</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到实验室这么多考研的童鞋，自己觉得得去分享点东西把，把自己会的分享给他们吧。&lt;/p&gt;
&lt;p&gt;这次只是单链表的创建、插入、删除、查找&lt;/p&gt;
&lt;p&gt;单链表的c语言代码加详细注释，双向链表和循环链表待更新&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>操作系统--页面置换算法</title>
    <link href="https://LTitan.github.io/2018/06/16/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <id>https://LTitan.github.io/2018/06/16/页面置换算法/</id>
    <published>2018-06-16T02:16:59.000Z</published>
    <updated>2018-09-25T09:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>###最佳置换算法<br>本人只是简单的列举三种算法的解题过程，但是实际问题得具体分析，感谢刘静文学姐，对缺页率的计算加已改正。</p><p>假设系统给某进程分配了三个物理块，有以下的页面号引用串：</p><p><img src="/images/2018/06/1.png" alt="alt"></p><p>则前三次装入内存并未发生中断，但是缺页，如下:</p><p><img src="/images/2018/06/2.png" alt="alt"></p><p>第四次时，在页中未发现2,发生缺页中断，根据最佳置换算法，发生一下操作：<br>即舍弃内存页中引用串下次出现的最大值</p><p><img src="/images/2018/06/3.png" alt="alt"><br>== &lt;7,0,1&gt; -&gt; &lt;2,0,1&gt; ==</p><p>第五次时0存在，不会发生缺页中断</p><p>第六次3在内存页中未找到，缺页中断发生，置换：</p><p><img src="/images/2018/06/4.png" alt="alt"><br>== &lt;2,0,1&gt; -&gt; &lt;2,0,3&gt; ==</p><p>……<br>依次类推，最后结果如下：</p><p><img src="/images/2018/06/5.png" alt="alt"></p><p>&lt;2,7,1&gt;</p><p>缺页率为：<br>前三次未发生缺页中断，但是需要调入内存，仍属于缺页范围。<br>前三次加上红框缺页次数6 总次数17 f=(6+3)/17×100%=52.9%</p><p>FIFO 算法</p><p>先进先出算法<br>还是以前的数据，有三个物理块，数据如下,且前三次不会发生缺页中断：</p><p><img src="/images/2018/06/2.png" alt="alt"></p><p>第四次时发生，缺页中断，先进先出算法：7先进的，所以7先出：</p><p><img src="/images/2018/06/6.png" alt="alt"><br>== &lt;7,0,1&gt; -&gt; &lt;2,0,1&gt; ==</p><p>第5次时未发生缺页中断<br>第六次时，3未找到，发生缺页中断，如下：</p><p><img src="/images/2018/06/7.png" alt="alt"><br>== &lt;2,0,1&gt; -&gt; &lt;2,3,1&gt; ==</p><p>依次类推，最终结果如下：</p><p><img src="/images/2018/06/8.png" alt="alt"><br>&lt;7,1,2&gt;</p><p>缺页率计算如下：<br>前三次未发生缺页中断，但是需要调入内存，仍属于缺页范围。<br>前三次加上红框缺页次数10 总次数17 f=(10+3)/17×100%=76.5%<br>这个算法比上者算法接近多一倍</p><p>##LRU算法（最近最久未使用）</p><p>还是如上数据，前三次结果未改变：<br><img src="/images/2018/06/2.png" alt="alt"></p><p>第四次时，和FIFO算法一致：</p><p><img src="/images/2018/06/9.png" alt="alt"><br>== &lt;7,0,1&gt; -&gt; &lt;2,0,1&gt; ==</p><p>第五次未改变，第六次发生缺页中断，如下，最好比较FIFO和LRU的区别：</p><p><img src="/images/2018/06/10.png" alt="alt"><br>== &lt;2,0,1&gt; -&gt; &lt;2,0,3&gt; ==</p><p>依次类推，最后结果如下：</p><p><img src="/images/2018/06/11.png" alt="alt"><br>&lt;1,7,2&gt;</p><p>缺页率计算如下：<br>前三次未发生缺页中断，但是需要调入内存，仍属于缺页范围。<br>前三次加上红框缺页次数8 总次数17 f=(8+3)/17×100%=64.7%</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###最佳置换算法&lt;br&gt;
本人只是简单的列举三种算法的解题过程，但是实际问题得具体分析，感谢刘静文学姐，对缺页率的计算加已改正。&lt;/p&gt;
&lt;p&gt;假设系统给某进程分配了三个物理块，有以下的页面号引用串：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/06/1.
      
    
    </summary>
    
    
      <category term="OS" scheme="https://LTitan.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>进程同步问题</title>
    <link href="https://LTitan.github.io/2018/06/13/%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    <id>https://LTitan.github.io/2018/06/13/进程同步问题/</id>
    <published>2018-06-13T02:16:59.000Z</published>
    <updated>2018-09-25T09:51:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>#读写者问题(多个)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int wmutex=1,rmutex=1;//读写信号量</span><br><span class="line">   int readCount=0;//读者数量</span><br><span class="line">   void Writer();</span><br><span class="line">   void Reader();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       Reader();</span><br><span class="line">           Writer();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   //写者：</span><br><span class="line">   void Writer()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)&#123;</span><br><span class="line">   P(wmutex);</span><br><span class="line">       ...</span><br><span class="line">       写书</span><br><span class="line">       ...</span><br><span class="line">       V(wmutex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   //读者</span><br><span class="line">   void Reader()</span><br><span class="line">   &#123;</span><br><span class="line">  while(1)</span><br><span class="line">       &#123;</span><br><span class="line">   P(rmutex);</span><br><span class="line">       if(readCount==0)</span><br><span class="line">       P(wmutex);</span><br><span class="line">       readCount++;</span><br><span class="line">       V(rmutex);</span><br><span class="line">       ...</span><br><span class="line">       读书</span><br><span class="line">       ...</span><br><span class="line">       P(rmutex);</span><br><span class="line">       readCount--;</span><br><span class="line">       if(readCount==0)</span><br><span class="line">       V(wmutex);</span><br><span class="line">       V(rmutex);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>#哲学家就餐问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int chopstick[]=&#123;1,1,1,1,1&#125;;//五个筷子</span><br><span class="line">   int mutex=1;</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       switch(i)</span><br><span class="line">           &#123;</span><br><span class="line">       V(SB);</span><br><span class="line">           case 1~5: Pi();break;</span><br><span class="line">           &#125;</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   Pi()//第i个哲学家进餐</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(mutex);              //在取筷子前获得互斥量</span><br><span class="line">   P(chopstick[i]);       //取左边筷子</span><br><span class="line">   P(chopstick[(i+1)%5]); //取右边筷子</span><br><span class="line">   V(mutex);              //释放取筷子的信号量</span><br><span class="line">           ...</span><br><span class="line">  eat;                   //进餐</span><br><span class="line">           ...</span><br><span class="line">   V(chopstick[i]);       //放回左边筷子</span><br><span class="line">   V(chopstick[(i+1)%5]); //放回右边筷子</span><br><span class="line">           ...</span><br><span class="line">   think;//思考</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>#生产者消费者问题</p><p>== 一个生产者 一个消费者 一个缓冲器：==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">int buffer;//1 表示生产 0表示消费</span><br><span class="line">   int empty=1,full=0;//空和满</span><br><span class="line">   void producer();</span><br><span class="line">   void consumer();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       producer();   consumer();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">    void producer()</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       ...</span><br><span class="line">           生产</span><br><span class="line">           ...</span><br><span class="line">       P(empty);</span><br><span class="line">           buffer=1;</span><br><span class="line">           V(full);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void consumer()</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(full);</span><br><span class="line">           buffer=0;</span><br><span class="line">           V(empty);</span><br><span class="line">           ...</span><br><span class="line">           消费</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><mark>一个生产者 一个消费者 n个缓冲器：</mark></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">int buffer[1024],t=0,k=0;</span><br><span class="line">   int empty=1,full=0;</span><br><span class="line">   void producer();</span><br><span class="line">   void consumer();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       producer();   consumer();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">    void producer()</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       ...</span><br><span class="line">           生产</span><br><span class="line">           ...</span><br><span class="line">           P(empty);</span><br><span class="line">           buffer[k]=1;</span><br><span class="line">           k=(++k)%n;</span><br><span class="line">           V(full);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void consumer()</span><br><span class="line">    &#123;</span><br><span class="line">    while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(full);</span><br><span class="line">           buffer[t]=0;</span><br><span class="line">           t=(++t)%n;</span><br><span class="line">           V(empty);</span><br><span class="line">           ...</span><br><span class="line">           消费</span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>#司机与售票员问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int s1=0,s2=0;</span><br><span class="line">   void P1();//司机</span><br><span class="line">   void P2();//售票员</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       P1();   p2();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   void P1()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)&#123;</span><br><span class="line">   P(s1);</span><br><span class="line">       ...</span><br><span class="line">       启动</span><br><span class="line">       正常行驶</span><br><span class="line">       到站</span><br><span class="line">       ...</span><br><span class="line">       V(s2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void P2()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       关门</span><br><span class="line">       V(s1);</span><br><span class="line">           售票</span><br><span class="line">           P(s2);</span><br><span class="line">           开门</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>#吃水果</p><p>问题描述<br>桌子上有一只盘子，最多可容纳两个水果，每次只能放人或取出一个水果。爸爸专向盘子中放苹果(apple)，妈妈专向盘子中放桔子(orange)，1个儿子专等吃盘子中的桔子，1个女儿专等吃盘子中的苹果。请用P、V操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">int mutex=1;</span><br><span class="line">   int empty=2;</span><br><span class="line">   int apple=0,orange=0;</span><br><span class="line">   void father(), mother();</span><br><span class="line">   void   son(),daughter();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       father(); mother();</span><br><span class="line">       son(); daughter();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   void father()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(empty);</span><br><span class="line">           P(mutex);</span><br><span class="line">           put an apple;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(apple);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void mother()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(empty);</span><br><span class="line">           P(mutex);</span><br><span class="line">           put an orange;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(orange);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void son()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(orange);</span><br><span class="line">           P(mutex);</span><br><span class="line">           eat an oeange;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(empty);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   void daughter()</span><br><span class="line">   &#123;</span><br><span class="line">   while(1)</span><br><span class="line">       &#123;</span><br><span class="line">       P(apple);</span><br><span class="line">           P(mutex);</span><br><span class="line">           eat an apple;</span><br><span class="line">           V(mutex);</span><br><span class="line">           V(empty);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>#独木桥问题<br>某条河上只有一座独木桥，以便行人过河。现在河的两边都有人要过桥，按照下面的规则过桥。为了保证过桥安全，请用P、V操作分别实现正确的管理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">int SA=1,SB=1,mutex=1;</span><br><span class="line">   int countA=0,countB=0;</span><br><span class="line">   void A(),B();</span><br><span class="line">   int main()</span><br><span class="line">   &#123;</span><br><span class="line">   cobegin</span><br><span class="line">       A();</span><br><span class="line">       B();</span><br><span class="line">       coend;</span><br><span class="line">   &#125;</span><br><span class="line">   void A()</span><br><span class="line">   &#123;</span><br><span class="line">   P(SA);</span><br><span class="line">       if(countA==0)</span><br><span class="line">       &#123;</span><br><span class="line">       P(mutex);</span><br><span class="line">           countA++;</span><br><span class="line">       &#125;</span><br><span class="line">       V(SA);</span><br><span class="line">       过独木桥;</span><br><span class="line">       P(SA);</span><br><span class="line">       countA--;</span><br><span class="line">       if(countA==0)</span><br><span class="line">       &#123;</span><br><span class="line">       V(metux);</span><br><span class="line">       &#125;</span><br><span class="line">       V(SA);</span><br><span class="line">   &#125;</span><br><span class="line">   void B()</span><br><span class="line">   &#123;</span><br><span class="line">   P(SB);</span><br><span class="line">       if(countB==0)</span><br><span class="line">       &#123;</span><br><span class="line">       P(mutex);</span><br><span class="line">           countB++;</span><br><span class="line">       &#125;</span><br><span class="line">       V(SB);</span><br><span class="line">       过独木桥;</span><br><span class="line">       P(SB);</span><br><span class="line">       countB--;</span><br><span class="line">       if(countB==0)</span><br><span class="line">       &#123;</span><br><span class="line">       V(metux);</span><br><span class="line">       &#125;</span><br><span class="line">       V(SB);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#读写者问题(多个)&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/sp
      
    
    </summary>
    
    
      <category term="OS" scheme="https://LTitan.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 蒙太奇效果</title>
    <link href="https://LTitan.github.io/2018/06/08/OpenCV%20%E8%92%99%E5%A4%AA%E5%A5%87%E6%95%88%E6%9E%9C/"/>
    <id>https://LTitan.github.io/2018/06/08/OpenCV 蒙太奇效果/</id>
    <published>2018-06-08T03:30:22.000Z</published>
    <updated>2018-10-24T12:35:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>展示一下图片的效果</p><p><em><strong>原图</strong></em></p><p><img src="/images/2018/06/change.jpeg" alt="alt"></p><p><em><strong>效果图</strong></em></p><p><img src="/images/2018/06/over.jpeg" alt="alt"></p><p><em><strong>拼接图</strong></em></p><p><img src="/images/2018/06/pin.png" alt="alt"></p><p>代码区：注释即为思想</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat src=imread(<span class="string">"/media/lyf/doc/蒙太奇/change.jpeg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(src.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    resize(src,src,Size(),<span class="number">0.5</span>,<span class="number">0.5</span>);</span><br><span class="line">    <span class="comment">//长宽能放下多少张小图片</span></span><br><span class="line">    <span class="keyword">int</span> rows=src.rows,cols=src.cols;</span><br><span class="line">    <span class="keyword">int</span> much_row=rows/<span class="number">50</span>,much_col=cols/<span class="number">50</span>;</span><br><span class="line">    much_col=much_col*<span class="number">50</span>&lt;cols?much_col+<span class="number">1</span>:much_col;</span><br><span class="line">    much_row=much_row*<span class="number">50</span>&lt;rows?much_row+<span class="number">1</span>:much_row;</span><br><span class="line"></span><br><span class="line">    Mat over=Mat(much_row*<span class="number">50</span>,much_col*<span class="number">50</span>,CV_8UC3,Scalar(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>));</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    Mat micPic,temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;much_row;++i)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;much_col;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//读取拼接的图片</span></span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> filename=<span class="string">"/media/lyf/doc/蒙太奇/m"</span>;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">            ss&lt;&lt;rand()%<span class="number">22</span>+<span class="number">1</span>;</span><br><span class="line">            filename+=ss.str()+<span class="string">".jpeg"</span>;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;filename&lt;&lt;endl;</span></span><br><span class="line">            micPic=imread(filename,CV_LOAD_IMAGE_UNCHANGED);</span><br><span class="line">            <span class="keyword">if</span>(micPic.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"读取过程中出现错误"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;micPic.channels()&lt;&lt;endl;</span></span><br><span class="line">            resize(micPic,micPic,Size(<span class="number">50</span>,<span class="number">50</span>));</span><br><span class="line">            temp=Mat(over,Rect(j*<span class="number">50</span>,i*<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>));</span><br><span class="line">            micPic.copyTo(temp);</span><br><span class="line">            micPic.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将图片转为 float类型的便于比例的分割</span></span><br><span class="line">    Mat src_32f,over_32f;</span><br><span class="line">    src.convertTo(src_32f,CV_32FC3);</span><br><span class="line">    over.convertTo(over_32f,CV_32FC3);</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//黄金比列</span></span><br><span class="line"></span><br><span class="line">            over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">0</span>] = saturate_cast&lt;<span class="keyword">float</span>&gt;(<span class="number">0.382</span>*over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">0</span>]+<span class="number">0.618</span>*src_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">0</span>]);</span><br><span class="line">            over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">1</span>] = saturate_cast&lt;<span class="keyword">float</span>&gt;(<span class="number">0.382</span>*over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">1</span>]+<span class="number">0.618</span>*src_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">1</span>]);</span><br><span class="line">            over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">2</span>] = saturate_cast&lt;<span class="keyword">float</span>&gt;(<span class="number">0.382</span>*over_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">2</span>]+<span class="number">0.618</span>*src_32f.at&lt;Vec3f&gt;(i, j)[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转为正常图片格式 uchar</span></span><br><span class="line">    over_32f.convertTo(over,CV_8UC3);</span><br><span class="line">    over=Mat (over,Rect(<span class="number">0</span>,<span class="number">0</span>,cols,rows));</span><br><span class="line">    imshow(<span class="string">"原图"</span>,src);</span><br><span class="line">    imshow(<span class="string">"生成的"</span>,over);</span><br><span class="line">    resize(over,over,Size(),<span class="number">1.5</span>,<span class="number">1.5</span>);</span><br><span class="line">    imwrite(<span class="string">"over.jpeg"</span>,over);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;展示一下图片的效果&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;原图&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/06/change.jpeg&quot; alt=&quot;alt&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;效果图&lt;/strong&gt;&lt;/e
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>转移linux（一）qt+opencv3.3视频播放器加摄像头读取</title>
    <link href="https://LTitan.github.io/2018/06/01/%E8%BD%AC%E7%A7%BBlinux%EF%BC%88%E4%B8%80%EF%BC%89qt+opencv3.3%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E5%8A%A0%E6%91%84%E5%83%8F%E5%A4%B4%E8%AF%BB%E5%8F%96/"/>
    <id>https://LTitan.github.io/2018/06/01/转移linux（一）qt+opencv3.3视频播放器加摄像头读取/</id>
    <published>2018-06-01T01:30:22.000Z</published>
    <updated>2018-10-24T12:40:07.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="windows-mfc-c-玩不了了-打算走嵌入式线路了"><a class="markdownIt-Anchor" href="#windows-mfc-c-玩不了了-打算走嵌入式线路了"></a> windows MFC c# 玩不了了 打算走嵌入式线路了</h4><p>从opencv自己编译了n天，到今天第一个qt项目，差不多两周吧，自己电脑实体机装了**deep in linux ** 和 <strong>windows</strong>双系统，所以体验体验linux编程的乐趣</p><hr><p><strong>QT cteater</strong>的设计师界面效率快的不要不要的，更何况是c++，而且还吹嘘的什么跨平台。</p><p>附上开发的设计图</p><p><img src="/images/2018/06/qt1.png" alt="alt"></p><p>软件截图:</p><p><img src="/images/2018/06/video1.png" alt="alt"></p><p>界面来讲还好吧，比mfc好看，主要视频还是用到QT自带的多线程来逐帧播放的，调试了5个小时，哈哈哈还是挺欣慰的，以后打算入手树梅派来做项目了。</p><p>就简单的附上视频的按钮以及核心代码吧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MainWindow::on_openFileBtn_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开视频文件按钮 有播放的视频的话会先停止</span></span><br><span class="line">    isOpenFile=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(capture.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        capture.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//文件类型的对话框 不需要用指针新建一个类</span></span><br><span class="line">    <span class="comment">//自行可以添加视频格式</span></span><br><span class="line">    QString FileName=QFileDialog::getOpenFileName(<span class="keyword">this</span>,tr(<span class="string">"打开文件"</span>),<span class="string">"."</span>,</span><br><span class="line">                                              tr(<span class="string">"Video Files(*.avi *.mp4 *.flv)"</span>));</span><br><span class="line">    <span class="comment">// capture.open(FileName.toLocal8Bit.data());  //防止字符串乱码转化</span></span><br><span class="line">    capture.open(FileName.toStdString());<span class="comment">//字符串(全英文目录比较好)的转化</span></span><br><span class="line">    <span class="keyword">if</span>(capture.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        rate=capture.get(CV_CAP_PROP_FPS);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(isOpenFile)</span><br><span class="line">        &#123;</span><br><span class="line">            vd_x=capture.get(CV_CAP_PROP_FRAME_COUNT);</span><br><span class="line">        ui-&gt;videoLong-&gt;setRange(<span class="number">0</span>,vd_x);</span><br><span class="line">            &#125;</span><br><span class="line">        capture&gt;&gt;frame;</span><br><span class="line">        <span class="keyword">if</span>(!frame.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//自适应窗口大小</span></span><br><span class="line">            width_x=ui-&gt;ImageLabel-&gt;width()*<span class="number">1.0</span>/frame.cols;</span><br><span class="line">            height_x=ui-&gt;ImageLabel-&gt;height()*<span class="number">1.0</span>/frame.rows;</span><br><span class="line"></span><br><span class="line">            cv::resize(frame,frame,Size(),width_x,height_x);</span><br><span class="line">        image=Mat2QImage(frame);</span><br><span class="line">        <span class="comment">//显示在label上</span></span><br><span class="line">        ui-&gt;ImageLabel-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line"></span><br><span class="line">            timer=<span class="keyword">new</span> QTimer(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//定时器线程 时间设置 相当与帧率</span></span><br><span class="line">            timer-&gt;setInterval(<span class="number">1000</span>/rate);</span><br><span class="line">            connect(timer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(nextFrame()));</span><br><span class="line"></span><br><span class="line">            timer-&gt;start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">QImage <span class="title">Mat2QImage</span><span class="params">(Mat cvImg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//Mat 类型转 QImage  类似与Mat转bitmap</span></span><br><span class="line">    QImage qImg;</span><br><span class="line">    <span class="comment">//判断通道个数</span></span><br><span class="line">    <span class="keyword">if</span>(cvImg.channels()==<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cvtColor(cvImg,cvImg,CV_BGR2RGB);</span><br><span class="line"></span><br><span class="line">        qImg=QImage((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)(cvImg.data),</span><br><span class="line">                cvImg.cols,cvImg.rows,</span><br><span class="line">                cvImg.cols*cvImg.channels(),</span><br><span class="line">                QImage::Format_RGB888</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(cvImg.channels()==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        qImg=QImage((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)(cvImg.data),</span><br><span class="line">                cvImg.cols,cvImg.rows,</span><br><span class="line">                cvImg.cols*cvImg.channels(),</span><br><span class="line">                QImage::Format_Indexed8</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        qImg=QImage((<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *)(cvImg.data),</span><br><span class="line">                cvImg.cols,cvImg.rows,</span><br><span class="line">                cvImg.cols*cvImg.channels(),</span><br><span class="line">                QImage::Format_RGB888</span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> qImg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MainWindow::nextFrame()</span><br><span class="line">&#123;</span><br><span class="line">    capture&gt;&gt;frame;</span><br><span class="line">    <span class="keyword">if</span>(!frame.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调整大小</span></span><br><span class="line">        cv::resize(frame,frame,Size(),width_x,height_x);</span><br><span class="line">    image=Mat2QImage(frame);</span><br><span class="line">        ui-&gt;ImageLabel-&gt;setPixmap(QPixmap::fromImage(image));</span><br><span class="line">        <span class="keyword">if</span>(isOpenFile)</span><br><span class="line">        &#123;</span><br><span class="line">            ui-&gt;videoLong-&gt;setValue((<span class="keyword">int</span>)(capture.get(CV_CAP_PROP_POS_FRAMES)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;windows-mfc-c-玩不了了-打算走嵌入式线路了&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#windows-mfc-c-玩不了了-打算走嵌入式线路了&quot;&gt;&lt;/a&gt; windows MFC c# 玩不了了 打算走嵌入式线路了&lt;/
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>图论--最短路径和最小生成树</title>
    <link href="https://LTitan.github.io/2018/04/25/%E5%9B%BE%E8%AE%BA--%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%92%8C%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>https://LTitan.github.io/2018/04/25/图论--最短路径和最小生成树/</id>
    <published>2018-04-25T09:30:22.000Z</published>
    <updated>2018-10-24T12:41:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>######图的表示呢分为邻接矩阵和邻接链表。其主要算法层出不穷，这里主要介绍最短路径的ford和dijsktra，单源最短路径，思维可能有点局限，有什么好的想法可以联系我，代码有如雷同，不怨俺.<br>(数组d[]表示求解的各点最短路径，from表示来源点，to表示目的点，cost表示权值，e(i,j)表示从i到j的边 )</p><p>题目来源：    <a href="https://www.nowcoder.com/acm/contest/96#question" target="_blank" rel="noopener">小木乃伊到我家</a></p><p>输入描述:<br>第一行输入两个整数n和m（2&lt;=n&lt;=m&lt;=200000），分别表示有n座城市和m条路，城市编号为1~n（快递姐姐所在城市为1，AA所在城市为n）。<br>接下来m行，每行输入3个整数u,v,w（u,v&lt;=n，w&lt;=100000），分别表示城市u和城市v之间有一条长为w的路。<br>输出描述:<br>输出结果占一行，输出快递姐姐到达AA家最短需要走多远的路，如果没有路能走到AA家，则输出“qwb baka”（不用输出双引号）。</p><p>示例1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">4 4</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">3 4 3</span><br><span class="line">2 3 1</span><br><span class="line">输出</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h4 id="ford-算法解决"><a class="markdownIt-Anchor" href="#ford-算法解决"></a> Ford 算法解决</h4><p>递推公式呢就是 d[i]=min{d[j]+cost[i][j]}</p><p>但是这个效率比较低啊，时间O(e^2)，这个算法程序就不详解了；</p><p><img src="/images/2018/04/ford.png" alt="alt"></p><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_E 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> from,to,cost;&#125;;</span><br><span class="line">edge es[MAX_E];<span class="comment">//变 起点 终点 权值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> d[MAX_E];<span class="comment">//最短距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V,E;<span class="comment">//顶点数 边数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WithMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=V;i++)</span><br><span class="line">        d[i]=INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">the_short_path</span><span class="params">(<span class="keyword">int</span> s)</span><span class="comment">//起点为s</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WithMax();</span><br><span class="line">    <span class="comment">//  fill(d,d+V,INF);</span></span><br><span class="line">    d[s]=<span class="number">0</span>;<span class="comment">//起点的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> update=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=E;i++)&#123;</span><br><span class="line">            edge e=es[i];</span><br><span class="line">            <span class="keyword">if</span>(d[e.from]!=INF&amp;&amp;d[e.to]&gt;(d[e.from]+e.cost))</span><br><span class="line">            &#123;</span><br><span class="line">                d[e.to]=d[e.from]+e.cost;</span><br><span class="line">                update=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(update==<span class="literal">false</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;V&gt;&gt;E)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">clock_t</span> start_time,end_time;</span><br><span class="line">    start_time=clock();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=E;i++)</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;es[i].from&gt;&gt;es[i].to&gt;&gt;es[i].cost;</span><br><span class="line">    the_short_path(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(d[V]==INF)  <span class="built_in">cout</span>&lt;&lt;<span class="string">"qwbbaka"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;d[V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    end_time=clock();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"运行时间: "</span>&lt;&lt;(<span class="keyword">double</span>)(end_time-start_time)/CLOCKS_PER_SEC&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####迪杰斯特拉算法</p><ul><li><p>引入(楼主可能是太特么懒了)：</p><p><img src="/images/2018/04/1-1.png" alt="alt"></p></li></ul><p>上图所示的图，求0到各个点的最短距离<br>具体原理如下，最后填充的哪个点进集合的位置，就是加上之前的最小距离</p><p><img src="/images/2018/04/2-1.png" alt="alt"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_A 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll to,cost;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(ll x,ll y)</span><br><span class="line">    &#123;</span><br><span class="line">    to=x;</span><br><span class="line">    cost=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> cost&gt;a.cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">ll V,E;<span class="comment">//顶点数和边数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; G[MAX_A];</span><br><span class="line">ll vis[MAX_A];</span><br><span class="line">ll d[MAX_A];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span><span class="comment">//参数为起点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    fill(vis,vis+V+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    fill(d,d+V+<span class="number">1</span>,INF);</span><br><span class="line">    d[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;node&gt; que;</span><br><span class="line">    que.push(node(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">    &#123;</span><br><span class="line">    node e=que.top();</span><br><span class="line">    que.pop();</span><br><span class="line">    <span class="keyword">if</span>(vis[e.to]) <span class="keyword">continue</span>;</span><br><span class="line">    vis[e.to]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> i=<span class="number">0</span>;i&lt;G[e.to].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll to=G[e.to][i].to,cost=G[e.to][i].cost;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!vis[to] &amp;&amp; d[to]&gt;d[e.to]+cost)</span><br><span class="line">        &#123;</span><br><span class="line">            d[to]=d[e.to]+cost;</span><br><span class="line">            que.push(node(to,d[to]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll f,t,c;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;V&gt;&gt;E)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">clock_t</span> <span class="keyword">start_t</span>,<span class="keyword">end_t</span>;</span><br><span class="line">        <span class="keyword">start_t</span>=clock();</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=V;i++)</span><br><span class="line">            G[i].clear();</span><br><span class="line">        <span class="keyword">for</span>(ll i=<span class="number">0</span>;i&lt;E;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;f&gt;&gt;t&gt;&gt;c;</span><br><span class="line">            G[f].push_back(node(t,c));</span><br><span class="line">            G[t].push_back(node(f,c));</span><br><span class="line">        &#125;</span><br><span class="line">        dijkstra();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;d[V]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">end_t</span>=clock();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(<span class="keyword">double</span>)(<span class="keyword">end_t</span>-<span class="keyword">start_t</span>)/CLOCKS_PER_SEC&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;######图的表示呢分为邻接矩阵和邻接链表。其主要算法层出不穷，这里主要介绍最短路径的ford和dijsktra，单源最短路径，思维可能有点局限，有什么好的想法可以联系我，代码有如雷同，不怨俺.&lt;br&gt;
(数组d[]表示求解的各点最短路径，from表示来源点，to表示目的
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>VS 自带数据库 MSSQLLocalDB 的使用方法</title>
    <link href="https://LTitan.github.io/2018/04/18/VS-%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%BA%93-MSSQLLocalDB-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://LTitan.github.io/2018/04/18/VS-自带数据库-MSSQLLocalDB-的使用方法/</id>
    <published>2018-04-18T05:30:22.000Z</published>
    <updated>2018-10-24T12:39:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>话说数据库开课了，机房用的是SQL server2008 r2,微软的这个东西有点大，但是已经有vs的童鞋有福利了，因为vs自带一个MSSqlLocalDatabase ，就是一个本地链接的数据库，我这里演示的是<strong>VS2015</strong>教程，2013、2017应该都可以的。</p><hr><p>##下面开始教程</p><p>#####首先打开vs</p><p><strong>1、找到菜单栏，点击工具，找到连接SQL Server，如下图</strong></p><p><img src="/images/2018/04/1.png" alt="alt"></p><p><strong>2、然后会弹出这个窗口，选择本地，选择MsSqlLocalDB，然后连接，注意一定是windows验证才可以，如图</strong></p><p><img src="/images/2018/04/2.png" alt="alt"></p><p><strong>3、会在VS侧栏有个 SQl Server对象资源管理器，如下图，没找到这个窗口的，再看下个图</strong></p><p><img src="/images/2018/04/3.png" alt="alt"></p><p><img src="/images/2018/04/4.png" alt="alt"></p><p><strong>4、打开这个数据库，就是那个小箭头，添加新数据库，我这个例子呢是用的教材P71 的习题6，你们也可以换其他的测试</strong></p><p><img src="/images/2018/04/5.png" alt="alt"></p><p><strong>5、经常用的，起个新名字，放个路径</strong></p><p><img src="/images/2018/04/6.png" alt="alt"></p><p><img src="/images/2018/04/7.png" alt="alt"></p><p><strong>6、打开这个新建的数据库（小箭头），然后鼠标右键，新建查询</strong></p><p><img src="/images/2018/04/8.png" alt="alt"></p><p><strong>7、写你自己定义的SQL语句，然后执行脚本，最后刷新数据库，就会完成操作</strong></p><p><img src="/images/2018/04/9.png" alt="alt"></p><p><img src="/images/2018/04/10.png" alt="alt"></p><p><img src="/images/2018/04/11.png" alt="alt"></p><p><strong>8、最后给表添加数据，这里先不考虑SQL语言插入了，显示表之后，自己往上填就行了</strong></p><p><img src="/images/2018/04/12.png" alt="alt"></p><p><img src="/images/2018/04/13.png" alt="alt"></p><p>除掉了烦人的sqlserver安装，还是挺省事吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;话说数据库开课了，机房用的是SQL server2008 r2,微软的这个东西有点大，但是已经有vs的童鞋有福利了，因为vs自带一个MSSqlLocalDatabase ，就是一个本地链接的数据库，我这里演示的是&lt;strong&gt;VS2015&lt;/strong&gt;教程，2013、
      
    
    </summary>
    
    
      <category term="others" scheme="https://LTitan.github.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV 帧差法运动物体追踪</title>
    <link href="https://LTitan.github.io/2018/03/28/OpenCV-%E5%B8%A7%E5%B7%AE%E6%B3%95%E8%BF%90%E5%8A%A8%E7%89%A9%E4%BD%93%E8%BF%BD%E8%B8%AA/"/>
    <id>https://LTitan.github.io/2018/03/28/OpenCV-帧差法运动物体追踪/</id>
    <published>2018-03-28T06:30:20.000Z</published>
    <updated>2018-10-24T12:32:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近迷上了物体跟踪的玩意,于是乎找了好多视频去看，翻来覆去呢就是用到了轮廓检测的api，还有耐心的不断的调试。</p><p>原理呢是帧差法（就是一帧一帧的比较）非HSV分离<br>看看视频 软件的工作流程</p><p><video src="/images/2018/03/233.mp4" controls="controls" width="820"><br>您的浏览器不支持 video 标签。<br></video></p><p>代码呢，emmm，真的是不好理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv/cv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv/highgui.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> SEAITVITV_VALUE = <span class="number">20</span>; <span class="comment">//阈值操作的起始范围 可手动调试</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> BLUR_SIZE = <span class="number">10</span>;<span class="comment">//blur 滤波Size大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> theObject[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;<span class="comment">//发现目标的坐标 x,y</span></span><br><span class="line"></span><br><span class="line">Rect objectBoundingRect = Rect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//目标跳动的矩形</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">intTostring</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int 类型 转为 string</span></span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; num;</span><br><span class="line"><span class="keyword">return</span> ss.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">searchForMovement</span><span class="params">(Mat thresgoldImage, Mat &amp;cameraFeed)</span></span></span><br><span class="line"><span class="function"></span>&#123;    <span class="comment">//寻找移动物</span></span><br><span class="line"></span><br><span class="line">Mat temp;</span><br><span class="line"><span class="keyword">bool</span> objectDetected;</span><br><span class="line"><span class="comment">//形参的阈值图像传给中间变量</span></span><br><span class="line">thresgoldImage.copyTo(temp);</span><br><span class="line"><span class="comment">//向量 用来存放轮廓点坐标 Point</span></span><br><span class="line"><span class="built_in">vector</span> &lt; <span class="built_in">vector</span>&lt;Point&gt; &gt; contours;</span><br><span class="line"><span class="comment">//向量 用来存放层次</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Vec4i&gt; hierarchy;</span><br><span class="line"><span class="comment">//调用api 来获取层次和轮廓点</span></span><br><span class="line">findContours(temp, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);</span><br><span class="line"><span class="comment">//判断轮廓点的个数是否为0</span></span><br><span class="line"><span class="keyword">if</span> (contours.size() &gt; <span class="number">0</span>) objectDetected = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    objectDetected = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (objectDetected)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//找最大的轮廓点</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt; &gt; largesContours;</span><br><span class="line">    largesContours.push_back(contours.at(contours.size() - <span class="number">1</span>));</span><br><span class="line">    objectBoundingRect = boundingRect(largesContours.at(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//约找出接近中心位置的点</span></span><br><span class="line">    <span class="keyword">int</span> xpos = objectBoundingRect.x + objectBoundingRect.width / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ypos = objectBoundingRect.y + objectBoundingRect.width / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//传给全局变量暂放坐标</span></span><br><span class="line">    theObject[<span class="number">0</span>] = xpos; theObject[<span class="number">1</span>] = ypos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = theObject[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> y = theObject[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//画一个圆圈</span></span><br><span class="line">circle(cameraFeed, Point(x, y), <span class="number">20</span>, Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="comment">//画十字架</span></span><br><span class="line">line(cameraFeed, Point(x, y), Point(x, y - <span class="number">25</span>),Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>);</span><br><span class="line">line(cameraFeed, Point(x, y), Point(x, y + <span class="number">25</span>), Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">line(cameraFeed, Point(x, y), Point(x<span class="number">-25</span>, y ), Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line">line(cameraFeed, Point(x, y), Point(x+<span class="number">25</span>, y ), Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>);</span><br><span class="line"><span class="comment">//输出坐标</span></span><br><span class="line">putText(cameraFeed, <span class="string">"tracking at:("</span> + intTostring(x) + <span class="string">","</span> + intTostring(y) + <span class="string">")"</span>, Point(x, y), <span class="number">1</span>, <span class="number">1</span>, Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按键是否调试</span></span><br><span class="line"><span class="keyword">bool</span> debugMode = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//按键是否跟踪</span></span><br><span class="line"><span class="keyword">bool</span> trackingEnable = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//是否暂停视频</span></span><br><span class="line"><span class="keyword">bool</span> pause = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//视频取帧的frame1 frame2</span></span><br><span class="line">Mat frame1, frame2;</span><br><span class="line"><span class="comment">//上者灰度图像</span></span><br><span class="line">Mat gray1, gray2;</span><br><span class="line"><span class="comment">//两者的不同图像</span></span><br><span class="line">Mat differenceImg;</span><br><span class="line"><span class="comment">//视频类</span></span><br><span class="line">VideoCapture capture;</span><br><span class="line"><span class="comment">//阈值后的图像</span></span><br><span class="line">Mat thres;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)<span class="comment">//不断的播放视频 进行调试</span></span><br><span class="line">&#123;</span><br><span class="line">    capture.open(<span class="string">"3.mp4"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!capture.isOpened())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打开视频失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//int total = capture.get(CV_CAP_PROP_FRAME_COUNT);</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; total &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//获取当前帧 与总帧进行比较 从而循环</span></span><br><span class="line">    <span class="keyword">while</span> (capture.get(CV_CAP_PROP_POS_FRAMES) &lt; capture.get(CV_CAP_PROP_FRAME_COUNT) - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//捕获frame1</span></span><br><span class="line">        capture.read(frame1);</span><br><span class="line">        <span class="comment">//转为灰度图</span></span><br><span class="line">        cvtColor(frame1, gray1, COLOR_BGR2GRAY);</span><br><span class="line">        <span class="comment">//捕获frame2</span></span><br><span class="line">        capture.read(frame2);</span><br><span class="line">        <span class="comment">//转为灰度图</span></span><br><span class="line">        cvtColor(frame2, gray2, COLOR_BGR2GRAY);</span><br><span class="line">        <span class="comment">//调用api 找出两者不同的区域 存入differenceImg</span></span><br><span class="line">        absdiff(gray1, gray2, differenceImg);</span><br><span class="line">        <span class="comment">//阈值操作</span></span><br><span class="line">        threshold(differenceImg, thres, SEAITVITV_VALUE, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">        <span class="comment">//滤波 去噪点</span></span><br><span class="line">        blur(thres, thres, Size(BLUR_SIZE, BLUR_SIZE));</span><br><span class="line">        <span class="comment">//再进行一遍阈值</span></span><br><span class="line">        threshold(thres, thres, SEAITVITV_VALUE, <span class="number">255</span>, THRESH_BINARY);</span><br><span class="line">        <span class="comment">//是否进入调试模式</span></span><br><span class="line">            <span class="keyword">if</span> (debugMode == <span class="literal">true</span>) &#123;</span><br><span class="line">            imshow(<span class="string">"thres"</span>, thres);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//销毁窗口</span></span><br><span class="line">                destroyWindow(<span class="string">"thres"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是否进入追踪捕获模式</span></span><br><span class="line">            <span class="keyword">if</span> (trackingEnable) &#123;</span><br><span class="line">                searchForMovement( thres, frame1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//显示原图像</span></span><br><span class="line">            imshow(<span class="string">"frame"</span>, frame1);</span><br><span class="line">        <span class="keyword">switch</span> (waitKey(<span class="number">50</span>))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">27</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            trackingEnable = !trackingEnable;</span><br><span class="line">        <span class="keyword">if</span> (trackingEnable == <span class="literal">false</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"没有捕获"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕获开始"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            debugMode = !debugMode;</span><br><span class="line">        <span class="keyword">if</span> (debugMode == <span class="literal">false</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"调试模式退出\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"进入调试模式"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">112</span>:</span><br><span class="line">            pause = !pause;</span><br><span class="line">            <span class="keyword">if</span> (pause == <span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"暂停"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">while</span> (pause == <span class="literal">true</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (waitKey())</span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">112</span>:</span><br><span class="line">                        pause = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"开始"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//播放完后释放类</span></span><br><span class="line">    capture.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近迷上了物体跟踪的玩意,于是乎找了好多视频去看，翻来覆去呢就是用到了轮廓检测的api，还有耐心的不断的调试。&lt;/p&gt;
&lt;p&gt;原理呢是帧差法（就是一帧一帧的比较）非HSV分离&lt;br&gt;
看看视频 软件的工作流程&lt;/p&gt;
&lt;p&gt;&lt;video src=&quot;/images/2018/
      
    
    </summary>
    
    
      <category term="opencv" scheme="https://LTitan.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>新年？ 当然是烟花了！！！</title>
    <link href="https://LTitan.github.io/2018/02/26/%E6%96%B0%E5%B9%B4?-%E5%BD%93%E7%84%B6%E6%98%AF%E7%83%9F%E8%8A%B1%E4%BA%86%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>https://LTitan.github.io/2018/02/26/新年?-当然是烟花了！！！/</id>
    <published>2018-02-26T03:34:20.000Z</published>
    <updated>2018-10-24T12:43:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>###唉 又过年了</p><p>过年咱也送个礼物了，<a href="/images/2018/02/fire.zip">烟花绽放.exe</a>，献给你们</p><p>内容呢是在b站上跟大佬学的，还是用到了简单的easyX 绘图库</p><p>文件和源码呢，就在上传的文件里面，解压就能看到了。</p><p>我感觉就是烟花障眼法</p><p><img src="/images/2018/02/fire.png" alt="alt"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###唉 又过年了&lt;/p&gt;
&lt;p&gt;过年咱也送个礼物了，&lt;a href=&quot;/images/2018/02/fire.zip&quot;&gt;烟花绽放.exe&lt;/a&gt;，献给你们&lt;/p&gt;
&lt;p&gt;内容呢是在b站上跟大佬学的，还是用到了简单的easyX 绘图库&lt;/p&gt;
&lt;p&gt;文件和源码呢，就在上传
      
    
    </summary>
    
    
      <category term="others" scheme="https://LTitan.github.io/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>图的基本遍历算法 DFS and BFS</title>
    <link href="https://LTitan.github.io/2018/01/24/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95-DFS-and-BFS/"/>
    <id>https://LTitan.github.io/2018/01/24/图的基本遍历算法-DFS-and-BFS/</id>
    <published>2018-01-24T03:34:20.000Z</published>
    <updated>2018-10-24T12:45:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先介绍下dfs"><a class="markdownIt-Anchor" href="#先介绍下dfs"></a> 先介绍下DFS</h2><p>下面这张图呢是图的原来状态</p><p><img src="/images/2018/01/1.png" alt="alt"></p><p>这个gif呢是其深度优先遍历的过程，ppt做的，可能会失真</p><p><img src="/images/2018/01/dfs.gif" alt="alt"></p><p>遍历的思想有了，但是对于非稀疏图来讲利用图的邻接矩阵遍历效果是不是更好。<br>那么代码就来了；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stack&gt;</span><br><span class="line">/*</span><br><span class="line">图的深度优先搜索</span><br><span class="line">数据结构中介绍需要用到栈的帮助</span><br><span class="line">这里的栈用C++ STL的stack</span><br><span class="line">*/</span><br><span class="line">using namespace std;</span><br><span class="line">#define number 5</span><br><span class="line">//定义图的邻接矩阵</span><br><span class="line">void DFS(int start);</span><br><span class="line">int map[][5]=</span><br><span class="line">&#123;</span><br><span class="line">0,1,1,0,0,</span><br><span class="line">0,0,1,0,1,</span><br><span class="line">0,0,1,0,0,</span><br><span class="line">1,1,0,0,1,</span><br><span class="line">0,0,1,0,0</span><br><span class="line">&#125;;</span><br><span class="line">//访问过的顶点</span><br><span class="line">int visited[number + 1];</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//初始化数组为0，表示一个也没访问</span><br><span class="line">memset(visited, 0, sizeof(visited));</span><br><span class="line">for (int i = 1; i &lt;= number; i++)</span><br><span class="line">&#123;</span><br><span class="line">    if (visited[i] == 1)</span><br><span class="line">        continue;</span><br><span class="line">    DFS(i);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int start)</span><br><span class="line">&#123;</span><br><span class="line">stack&lt;int&gt; stk;</span><br><span class="line">//顶点入栈</span><br><span class="line">stk.push(start);</span><br><span class="line">//表示访问</span><br><span class="line">visited[start] = 1;</span><br><span class="line"></span><br><span class="line">bool IS_PUSH = false;//是否有新的顶点入栈</span><br><span class="line">while (!stk.empty())</span><br><span class="line">&#123;</span><br><span class="line">    IS_PUSH = false;</span><br><span class="line">    int p = stk.top();</span><br><span class="line">    for (int i = 1; i &lt;= number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (map[p - 1][i - 1] == 1 &amp;&amp; !visited[i])</span><br><span class="line">            //如果他俩联通，并且还没有访问过</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = 1;</span><br><span class="line">            stk.push(i);</span><br><span class="line">            IS_PUSH = true;//新顶点入栈</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!IS_PUSH)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span><br><span class="line">        stk.pop();//顶点出栈</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果，看图就能看出来了，不过代码只是更简单点了</p><h2 id="bfs"><a class="markdownIt-Anchor" href="#bfs"></a> BFS</h2><p><img src="/images/2018/01/2.png" alt="alt"></p><p><img src="/images/2018/01/bfs.gif" alt="alt"></p><p>代码用到队列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void BFS(int start)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; que;</span><br><span class="line">//顶点入队</span><br><span class="line">que.push(start);</span><br><span class="line">//表示访问</span><br><span class="line">visited[start] = 1;</span><br><span class="line"></span><br><span class="line">while (!que.empty())</span><br><span class="line">&#123;</span><br><span class="line">    int p = que.front();</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span><br><span class="line">    que.pop();</span><br><span class="line">    for (int i = 1; i &lt;= number; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (map[p - 1][i - 1] == 1 &amp;&amp; !visited[i])</span><br><span class="line">            //如果他俩联通，并且还没有访问过</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = 1;</span><br><span class="line">            que.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;先介绍下dfs&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#先介绍下dfs&quot;&gt;&lt;/a&gt; 先介绍下DFS&lt;/h2&gt;
&lt;p&gt;下面这张图呢是图的原来状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2018/01/1.png&quot; alt
      
    
    </summary>
    
    
      <category term="data-structure" scheme="https://LTitan.github.io/tags/data-structure/"/>
    
  </entry>
  
</feed>
