{"meta":{"title":"LTitan`s Blog","subtitle":"foolish","description":"good good study, day day up!","author":"lyf","url":"https://LTitan.github.io"},"pages":[{"title":"about","date":"2018-10-25T01:04:16.000Z","updated":"2018-10-25T01:04:16.269Z","comments":true,"path":"about/index.html","permalink":"https://LTitan.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-25T01:04:11.000Z","updated":"2018-10-25T01:04:11.765Z","comments":true,"path":"categories/index.html","permalink":"https://LTitan.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-10-25T01:47:55.321Z","updated":"2018-10-25T01:27:04.777Z","comments":true,"path":"links/index.html","permalink":"https://LTitan.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-25T01:03:59.000Z","updated":"2018-10-25T01:03:59.835Z","comments":true,"path":"tags/index.html","permalink":"https://LTitan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基于ORB的图像矫正","slug":"基于orb的图像矫正","date":"2018-07-25T04:30:22.000Z","updated":"2018-10-25T02:01:40.676Z","comments":true,"path":"2018/07/25/基于orb的图像矫正/","link":"","permalink":"https://LTitan.github.io/2018/07/25/基于orb的图像矫正/","excerpt":"","text":"单应性矩阵 在二维平面上，平面的单应性被定义为从一个平面到另一个平面的投影映射，就像我们拍一张照片时，从我们眼前的点一一映射到摄像机内部一样。英文学名叫做homography（单应性，ps:下面的鲁棒性就是稳定性。 下即为一个简单的3x3homo矩阵 \\left[ \\begin{matrix} h00 &amp; h01 &amp; h02 \\ h10 &amp; h11 &amp; h12 \\ h20 &amp; h21 &amp; h22 \\end{matrix} \\right ] \\tag{1} 其平面坐标变换对应为(原坐标为(x1,y1),其变换为(x2,y2)): [x1 y1 1]=H[x2 y2 1]=[h00h01h02 h10h11h12 h20h21h22][x2 y2 1]\\left[ \\begin{array}{c} x_1 \\ y_1 \\ 1 \\end{array} \\right] = H \\left[ \\begin{array}{c} x_2 \\ y_2 \\ 1 \\end{array} \\right] = \\left[ \\begin{array}{ccc} h{00} &amp; h{01} &amp; h{02} \\ h{10} &amp; h{11} &amp; h{12} \\ h{20} &amp; h{21} &amp; h_{22} \\end{array} \\right] \\left[ \\begin{array}{c} x_2 \\ y_2 \\ 1 \\end{array} \\right] [x1​ y1​ 1​]=H[x2​ y2​ 1​]=[h00​h01​h02 h10​h11​h12 h20​h21​h22​​][x2​ y2​ 1​] 下图为变换的例子 在OpenCV里面，单应矩阵的计算函数为 : Mat findHomography(inputArray points1,inputArray points2,int method) . 参数一为输入的x1，y1 点集 . 参数二为输入的 x2，y2 点集 . 参数三为计算方法：0 - 使用所有点的常规方法 RANSAC - 基于RANSAC的鲁棒方法 LMEDS - 最小中值稳健方法 RHO - 基于PROSAC的鲁棒方法 #关键点检测 上篇里有介绍基于ORB的关键点检测，舒服的是这个算法是至今最好最快的算法，其他的检测算法还有SURF，SIFT，etc….算法，效率而讲，500点一下还是差不多的，但是点越多的话ORB绝对胜出。 #关键点匹配 上篇的文章依然用着老的api，但是编译了最新的3.4之后api又发生了变化(mmp)，这次能直接detect 和compute一起用了。 其用到头文件 xfeatures2d/nonfree.hpp 命名空间 cv::xfeatures2d 检测器创建如下，只能处理灰度图像 1Ptr&lt;Feature2D&gt; orb = ORB::create(MAX_FEATURES);//智能指针传参为最大检测点数 图像矫正如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/xfeatures2d/nonfree.hpp&gt;#include &lt;opencv2/features2d.hpp&gt;using namespace std;using namespace cv;using namespace cv::xfeatures2d;const int MAX_FEATURES = 500;const float GOOD_MATCH_PERCENT = 0.15f;void alignImage(Mat&amp; img1, Mat&amp; img2, Mat&amp; dst, Mat h)&#123; Mat img1Gray, img2Gray;//灰度图 cvtColor(img1, img1Gray, COLOR_BGR2GRAY); cvtColor(img2, img2Gray, COLOR_BGR2GRAY);//灰度处理 vector&lt;KeyPoint&gt; keypoints1, keypoints2;//图1 关键点 图2 关键点 Mat descriptors1, descriptors2; Ptr&lt;Feature2D&gt; orb = ORB::create(MAX_FEATURES); orb-&gt;detectAndCompute(img1Gray, Mat(), keypoints1, descriptors1);//检测匹配 orb-&gt;detectAndCompute(img2Gray, Mat(), keypoints2, descriptors2);//检测匹配 vector&lt;DMatch&gt; matches; Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::create(&quot;BruteForce-Hamming&quot;); matcher-&gt;match(descriptors1, descriptors2, matches, Mat());//匹配描线 sort(matches.begin(), matches.end());//排序筛选优好的点 const int numGoodMatches = matches.size()*GOOD_MATCH_PERCENT; matches.erase(matches.begin() + numGoodMatches, matches.end()); Mat imMatches; drawMatches(img1, keypoints1, img2, keypoints2, matches, imMatches); imshow(&quot;match&quot;, imMatches); imwrite(&quot;F:\\\\match.jpg&quot;, imMatches); vector&lt;Point2f&gt; points1, points2; for (auto x : matches) &#123; points1.push_back(keypoints1[x.queryIdx].pt); points2.push_back(keypoints2[x.trainIdx].pt); &#125; h = findHomography(points1, points2, RANSAC); warpPerspective(img1, dst, h, img2.size());//旋转矫正&#125;int main()&#123; string refFilename=&quot;F:\\\\picture\\\\src.jpg&quot;;//原图路径 Mat src = imread(refFilename); string scanFilename = &quot;F:\\\\picture\\\\scanned.jpg&quot;;//扫描的或者电子版的图 Mat scan_src = imread(scanFilename); Mat imageRege, homo;//完成图像 和 homo矩阵 alignImage(src, scan_src, imageRege, homo); cout &lt;&lt; homo &lt;&lt; endl; imshow(&quot;dst&quot;, imageRege); imwrite(&quot;F:\\\\change.jpg&quot;, imageRege); waitKey();&#125;","categories":[],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://LTitan.github.io/tags/opencv/"}]},{"title":"opencv:基于ORB特征点匹配及图像拼接","slug":"opencv-基于ORB特征点匹配及图像拼接","date":"2018-07-21T02:18:59.000Z","updated":"2018-09-25T09:25:38.824Z","comments":true,"path":"2018/07/21/opencv-基于ORB特征点匹配及图像拼接/","link":"","permalink":"https://LTitan.github.io/2018/07/21/opencv-基于ORB特征点匹配及图像拼接/","excerpt":"","text":"#ORB简述 ORB（Oriented FAST and Rotated BRIEF）是一种快速特征点提取和描述的算法。ORB算法分为两部分，分别是特征点提取和特征点描述。特征提取是由FAST（Features from Accelerated Segment Test）算法发展来的，特征点描述是根据BRIEF（Binary Robust IndependentElementary Features）特征描述算法改进的。ORB特征是将FAST特征点的检测方法与BRIEF特征描述子结合起来，并在它们原来的基础上做了改进与优化。 下图是我在高数课本上进行的测试: #特征点匹配 例子里采集了3000个点吧对比一下，opencv3.3以后好像用上了智能指针Ptr对象，对象的创建只能用ptr模板创建，大概是因为图像再处理的过程中防止异常错误正常抛出吧。 两张原图： 123456789101112131415161718192021222324252627282930313233343536373839404142Mat image_src1,image_src2; Mat image_gray1,image_gray2; image_src1=imread(&quot;D:\\\\yy.jpg&quot;); cvtColor(image_src1,image_gray1,COLOR_BGR2GRAY);//转为灰度图 image_src2=imread(&quot;D:\\\\zz.jpg&quot;); cvtColor(image_src2,image_gray2,COLOR_BGR2GRAY);//转为灰度图 Ptr&lt;Feature2D&gt; oDetectors=ORB::create(3000);//创建orb对象，采集特征点 vector&lt;KeyPoint&gt; KeyPoints1,KeyPoints2;//关键点数组 oDetectors-&gt;detect(image_gray1,KeyPoints1);//采集左图特征点 oDetectors-&gt;detect(image_gray2,KeyPoints2);//采集右图特征点 Mat imageDec1,imageDec2; Ptr&lt;Feature2D&gt; ptor=ORB::create();//创建一个新的oeb对象，当然也可以用上面那个 ptor-&gt;compute(image_gray1,KeyPoints1,imageDec1);//描述特征点 ptor-&gt;compute(image_gray2,KeyPoints2,imageDec2);//描述特征点 flann::Index flannIndex(imageDec1,LshIndexParams(12,20,2), cvflann::FLANN_DIST_HAMMING); vector&lt;DMatch&gt; goodMatchPoints; Mat matchIndex(imageDec2.rows,2,CV_32SC1); Mat matchDistance(imageDec2.rows,2,CV_32FC1); flannIndex.knnSearch(imageDec2,matchIndex,matchDistance,2,flann::SearchParams());//采用k近似值 将匹配的索引和距离计算出来 for(int i=0;i &lt; matchDistance.rows;i++) &#123; float t=matchDistance.at&lt;float&gt;(i,0); float s=matchDistance.at&lt;float&gt;(i,1); if(t&lt;s*0.46)//相似度大约为0.46就算相符 &#123; DMatch part_matches(i,matchIndex.at&lt;int&gt;(i,0),t); goodMatchPoints.push_back(part_matches); &#125; &#125; Mat first_matching; drawMatches(image_src2,KeyPoints2,image_src1,KeyPoints1, goodMatchPoints,first_matching); imshow(&quot;Match&quot;,first_matching); 如图，匹配完成: #拼接 记录相似点，将另一图像适度旋转调整，然后拼接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071vector&lt;Point2f&gt; Conners(4);// 左上角 左下角 右上角 右下角void calcCorners(const Mat&amp; homo,const Mat&amp; input)&#123; double v2[]=&#123;0,0,1&#125;; double v1[3];//改变后值 Mat V2=Mat(3,1,CV_64FC1,v2); Mat V1=Mat(3,1,CV_64FC1,v1); //下面都是重复代码计算看懂一个即可 V1=homo*V2; Conners[0].x=v1[0]/v1[2]; Conners[0].y=v1[1]/v1[2]; v2[0]=0; v2[1]=input.rows; v2[2]=1; V2=Mat(3,1,CV_64FC1,v2); V1=Mat(3,1,CV_64FC1,v1); V1=homo*V2; Conners[1].x=v1[0]/v1[2]; Conners[1].y=v1[1]/v1[2]; v2[0]=input.cols; v2[1]=0; v2[2]=1; V2=Mat(3,1,CV_64FC1,v2); V1=Mat(3,1,CV_64FC1,v1); V1=homo*V2; Conners[2].x=v1[0]/v1[2]; Conners[2].y=v1[1]/v1[2]; v2[0]=input.cols; v2[1]=input.rows; v2[2]=1; V2=Mat(3,1,CV_64FC1,v2); V1=Mat(3,1,CV_64FC1,v1); V1=homo*V2; Conners[3].x=v1[0]/v1[2]; Conners[3].y=v1[1]/v1[2];&#125;main:://此处接着标题二的代码vector&lt;Point2f&gt; image_points1,image_points2; for(auto x:goodMatchPoints) &#123; image_points2.push_back(KeyPoints2[x.queryIdx].pt); image_points1.push_back(KeyPoints1[x.trainIdx].pt); &#125; Mat homo=findHomography(image_points1,image_points2,CV_RANSAC); cout&lt;&lt;&quot;homo matrix:&quot;&lt;&lt;homo&lt;&lt;endl; calcCorners(homo,image_src1); Mat imageTransform1,imageTransform2; warpPerspective(image_src1,imageTransform1,homo,Size(max(Conners[2].x, Conners[3].x),image_src2.rows)); imshow(&quot;12&quot;,imageTransform1); int dst_width=imageTransform1.cols; int dst_height=image_src2.rows; Mat dst(dst_height,dst_width,CV_8UC3); dst.setTo(0); imageTransform1.copyTo(dst(Rect(0,0,imageTransform1.cols,imageTransform1.rows))); image_src2.copyTo(dst(Rect(0,0,image_src2.cols,image_src2.rows))); imshow(&quot;pin&quot;,dst); 拼接完，如图： #优化拼接处 此处是借鉴别人的，因为自己也不可能凭空想到，哈哈，修复拼接处的线条问题。 1234567891011121314151617181920212223242526void optimizated(Mat &amp;src,Mat &amp;trans,Mat &amp;dst)&#123; int start=min(Conners[0].x,Conners[1].x); double processWidth=src.cols-start; int rows=dst.rows; int cols=src.cols; double alpha=1; for(int i=0;i&lt;rows;++i) &#123; uchar *p=src.ptr&lt;uchar&gt;(i); uchar *t=trans.ptr&lt;uchar&gt;(i); uchar *d=dst.ptr&lt;uchar&gt;(i); for(int j=start;j&lt;cols;++j) &#123; int k=j*3; if(t[k]==0&amp;&amp;t[k+1]==0&amp;&amp;t[k+2]==0) alpha=1; else alpha=(processWidth-j+start)/processWidth; d[k]=p[k]*alpha+t[k]*(1-alpha); d[k+1]=p[k+1]*alpha+t[k+1]*(1-alpha); d[k+2]=p[k+2]*alpha+t[k+2]*(1-alpha); &#125; &#125;&#125; 成品图效果如下:","categories":[],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://LTitan.github.io/tags/opencv/"}]},{"title":"数据结构(四) 双向循环链表","slug":"数据结构(四) 双向循环链表 ","date":"2018-07-16T05:16:59.000Z","updated":"2018-10-25T01:59:30.976Z","comments":true,"path":"2018/07/16/数据结构(四) 双向循环链表 /","link":"","permalink":"https://LTitan.github.io/2018/07/16/数据结构(四) 双向循环链表 /","excerpt":"","text":"又来安利福利了，双向和循环一起了吧，单讲双向没意思，结合在一起就有意思了，看完了第一篇的单链表应该看双向很轻松了。 运行截图 遗憾没有放上查找，请自己加上吧，正序找逆序找都是easy的 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;//双向循环链表 基本操作和单链表差不多，只不过他有自己的回头路了typedef struct _double_linked_list&#123; int data;//存放数据 struct _double_linked_list *front;//前指针 struct _double_linked_list *next;//后指针&#125;DouLinkedList;void traversing_postive(DouLinkedList *list)//正序遍历从头到尾&#123; DouLinkedList *p=list-&gt;next; DouLinkedList *head=list;//起始头位置 while(p!=head)//循环到头部就停止 &#123; printf(&quot;%d &quot;,p-&gt;data); p=p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;void traversing_reverse(DouLinkedList *list)&#123; DouLinkedList *p=list-&gt;front; DouLinkedList *head=list; while(p!=head)//循环到头部就停止 &#123; printf(&quot;%d &quot;,p-&gt;data); p=p-&gt;front; &#125; printf(&quot;\\n&quot;);&#125;void create_tail(DouLinkedList *list,const int n)//n还是创建的长度&#123; DouLinkedList *p=list; DouLinkedList *head=list; p-&gt;front=NULL; p-&gt;next=NULL; for(int i=0;i&lt;n;++i) &#123; DouLinkedList *temp; int data; temp=(DouLinkedList*)malloc(sizeof(DouLinkedList)); printf(&quot;请输入第%d个结点的数据\\n&quot;,i+1); scanf(&quot;%d&quot;,&amp;data); temp-&gt;data=data; head-&gt;front=temp;//头的前面指向插入的尾部 temp-&gt;next=head;//尾的下一个指向头部 这样就构成循环链表了 p-&gt;next=temp; temp-&gt;front=p; p=temp; &#125;&#125;int insert_node(DouLinkedList *list,int pos,int data)&#123; //链表的下标从1开始 if(pos&lt;1||list==NULL) return -1;//位置小于或者链表是空的 插入失败 DouLinkedList *head=list; DouLinkedList *p=list-&gt;next; int i=1;//计数i while(p!=head) &#123; if(i==pos) break;//找到前驱点就停止 ++i; p=p-&gt;next; &#125; if(i&lt;pos) return -1;//越界 DouLinkedList *newNode=(DouLinkedList*)malloc(sizeof(DouLinkedList)); newNode-&gt;data=data; newNode-&gt;front=p-&gt;front; p-&gt;front-&gt;next=newNode; newNode-&gt;next=p; p-&gt;front=newNode; return 1; &#125; int delete_node(DouLinkedList *list,int pos) &#123; if(pos&lt;1||list==NULL) return -1; DouLinkedList *p=list-&gt;next; DouLinkedList *head=list; int i=1; while(p!=head) &#123; if(i==pos) break; ++i; p=p-&gt;next; &#125; if(i&lt;pos) return -1; p-&gt;front-&gt;next=p-&gt;next; p-&gt;next-&gt;front=p-&gt;front; free(p); return 1;&#125;int main()&#123; DouLinkedList *mylist; mylist=(DouLinkedList*)malloc(sizeof(DouLinkedList));//新建一个头节点 create_tail(mylist,5); printf(&quot;正序遍历&quot;); traversing_postive(mylist); printf(&quot;逆序遍历&quot;); traversing_reverse(mylist); int flag=insert_node(mylist,2,666);//在第二个插入666 if(flag!=-1) puts(&quot;插入成功&quot;); else puts(&quot;插入失败&quot;); traversing_postive(mylist); flag=delete_node(mylist,3);//删除第三个 if(flag!=-1) puts(&quot;删除成功&quot;); else puts(&quot;删除失败&quot;); traversing_postive(mylist); return 0;&#125;","categories":[],"tags":[{"name":"data-structure","slug":"data-structure","permalink":"https://LTitan.github.io/tags/data-structure/"}]},{"title":"数据结构(二) 字符串的常规使用","slug":"数据结构(二) 字符串的常规使用 ","date":"2018-07-16T01:44:59.000Z","updated":"2018-09-25T09:38:44.015Z","comments":true,"path":"2018/07/16/数据结构(二) 字符串的常规使用 /","link":"","permalink":"https://LTitan.github.io/2018/07/16/数据结构(二) 字符串的常规使用 /","excerpt":"","text":"虽然字符串简单，但是在生活中的用处确实很广，就像论文查重，文章检索，没有字符串的数据结构和算法是实现不了的 我在这先放上c语言版的char数组，文章的下篇将介绍c++版的（唉，这两天感觉自己特别能得吧了）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;memory.h&gt; //简单点说字符串就是字符数组 //基本运算无非就是长度 比较 回文 模式匹配(查找) //模式匹配和回文我将会单独开文章的,请耐心等等吧 = = //1.求字符串的长度 这里用到strlen函数 //那为什么不用sizeof(str)/sizeof(char) 计算呢？ //原因是开辟了1024个长度不一定用满，用sizeof计算呢即为1024,而非字符串长度 int str_length(char *s) &#123; return strlen(s);//直接用strlen求解 &#125; //2.字符串比较 就是挨个比较字符串的字符 //可以用strcmp函数比较 也可以自己手写一个 int str_comparison_system(char *p,char *q)//函数意思为调用系统函数 &#123; //返回1 即p大 0即一样大小 -1即q大 return strcmp(p,q); &#125; int str_comparison_user(char *p,char *q)//这个比较函数为自己写的 &#123; //先求出各自的长度 遍历长度最小的字符串比较,防止越界 //这是作者自己想到的,有什么好的想法欢迎来补充 //如果面试提到的话，自己可以借鉴一下 int lenp=str_length(p); int lenq=str_length(q); int theMin=lenp&gt;lenq?lenq:lenp;//求出最短的长度 for(int i=0;i&lt;theMin;++i) &#123; if(p[i]==q[i]) continue; if(p[i]&gt;q[i]) return 1; if(p[i]&lt;q[i]) return -1; &#125; return lenp&gt;lenq?1:0;//这里的做法是为了防止p的前面与q一致,但是p后面有字符 //EG：abcdefg &gt; abcd &#125; int main() &#123; char str1[1024]=&quot;hello world&quot;;//c语言中我们用char数组表示字符串 char str2[500]=&quot;hello friends&quot;; printf(&quot;str1的长度:%d str2的长度:%d\\n&quot;,str_length(str1), str_length(str2)); //测试一下sizeof的区别 printf(&quot;str1的空间:%d\\n&quot;,sizeof(str1)/sizeof(char));//输出1024 //字符串系统和自己写的比较 printf(&quot;系统函数 比较结果:%d\\n&quot;,str_comparison_system(str1,str2)); printf(&quot;自己写函数 比较结果:%d\\n&quot;,str_comparison_user(str1,str2)); //小福利 送上汇编写的 memory 内存函数的使用 memset(str2,0,sizeof(str2));//内存设置 一般把数组清0用 /* 参数一是你要设置的数组首地址 参数二是字节填充大小 注意int是占8或4个字节全填上1的话 结果就肯定不是1了 参数三是你要填的字节长度 */ puts(str2); memcpy(str2,str1,sizeof(str2));//内存拷贝 // 与strcpy(str2,str1);大同小异 但实际上mem的效率是大于strcpy的 //参数一看就懂了 把str1拷贝给str2 但是最后的参数一定是谁短写谁，否则炸内存 puts(str2); puts(str1); return 0; &#125;c++版的string 数据类型 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() &#123; string str1=&quot;hello world&quot;; string str2=&quot;hello friends&quot;; //哎 是不是有疑问了？不用考虑字串的空间大小么？ //这里我解释：程序运行实在操作系统的堆上运行的，线程实在栈上运行的 //既然实在堆上运行的，就看你电脑内存了，所以你就可以不用管了 //string 可以用[] 下标访问 // string 的输入两种方式 空格能输入和不能输入 //接收空格的字符串输入 // getline(cin,str1);//意思就是接收一行 回车生效 //不能接收空格的输入 // cin&gt;&gt;str1; //求字符串的长度 string.length() cout&lt;&lt;&quot;str1的长度为&quot;&lt;&lt;str1.length()&lt;&lt;endl; //字符串比较 直接用 &lt;、== 或 &gt; 判断就行了 cout&lt;&lt;(str1&gt;str2)&lt;&lt;endl; //子串 string sub=str1.substr(5,3);//从5的位置截取3个长度 wo cout&lt;&lt;sub&lt;&lt;endl; //查找 时间效率为O(nlog(n)) 原理就是用的模式匹配 int flag=str1.find(&quot;lyf&quot;);//找不到返回-1 找到返回下标 cout&lt;&lt;flag&lt;&lt;endl; //删除 n个 和 全部 str1.erase(3,4);//从3的位置删除4个 cout&lt;&lt;str1&lt;&lt;endl; str1.clear();//全部删除 cout&lt;&lt;str1&lt;&lt;endl; //加法 连接运算符 cout&lt;&lt;(str1+str2)&lt;&lt;endl; return 0; &#125;","categories":[],"tags":[{"name":"data-structure","slug":"data-structure","permalink":"https://LTitan.github.io/tags/data-structure/"}]},{"title":"数据结构(三) 字符串模式匹配KMP和基于哈希的匹配","slug":"数据结构(三) 字符串模式匹配KMP和基于哈希的匹配","date":"2018-07-16T01:16:59.000Z","updated":"2018-09-25T09:37:00.248Z","comments":true,"path":"2018/07/16/数据结构(三) 字符串模式匹配KMP和基于哈希的匹配/","link":"","permalink":"https://LTitan.github.io/2018/07/16/数据结构(三) 字符串模式匹配KMP和基于哈希的匹配/","excerpt":"","text":"没想到吧，竟然是同一天写的，先安利一个kmp视频，看完之后你看代码就有感觉了。 但是还是感觉哈希流批，万物基于哈希（滑稽） ###链接 B站链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //用c++的编译器吧，这里我用到了动态内存 int *next; void getNext(char* p) &#123; int lenp = strlen(p); next[0] = -1; //第一个是未知的，就放上-1 int k = -1;//指针指在字符串最外面 int j = 0; //指针指在首地址上 while (j &lt; lenp - 1) &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p[j] == p[k]) &#123; ++k; ++j; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125; &#125; int Kmp(char* s, char* p) &#123; int i = 0; int j = 0; int lens = strlen(s); int lenp = strlen(p); while (i &lt; lens &amp;&amp; j &lt; lenp) &#123; //如果j = -1,或者当前字符匹配成功即 S[i] == P[j]，都令指针移动 if (j == -1 || s[i] == p[j]) &#123; i++; j++; &#125; else &#123; //如果j != -1，且当前字符匹配失败，则令 i 指针不懂，j 回退 j = next[j]; //next[j]即为j所对应的next值 &#125; &#125; if (j == lenp) return i - j; //返回下标 else return -1; &#125; int main() &#123; char str1[1024]=&quot;helloOWorldNotheloWhy??helhellelo&quot;; char str2[1024]=&quot;hellelo&quot;; next=new int[strlen(str2)+1];//next 数组长度应该比匹配串大一 getNext(str2); printf(&quot;%d&quot;,Kmp(str1,str2)); delete[] next; return 0; &#125;哈希匹配 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; //基于哈希的模式匹配 typedef unsigned long long ULL;//用编译器最大的数据类型 2^64 const ULL HashConst=100000007;//哈希基数 mod hashConst int hash_machting(char *a,char *b)//这次是判a是否在b中出现 &#123; int lena=strlen(a); int lenb=strlen(b); if(lena&gt;lenb) return -1;//a太长了 ULL t=1; //计算哈希计数的lena次方 for(int i=0;i&lt;lena;++i) t*=HashConst; //计算a和b为lena的前缀对应的哈希值 ULL ah=0,bh=0; for(int i=0;i&lt;lena;++i) ah=ah*HashConst+a[i]; for(int i=0;i&lt;lena;++i) bh=bh*HashConst+b[i]; //匹配 更新哈希值 for(int i=0;i+lena&lt;=lenb;i++) &#123; if(ah==bh) return i; if(i+lena&lt;lenb) bh=bh*HashConst+b[i+lena]-b[i]*t; &#125; return -1; &#125; int main() &#123; char str1[1024]=&quot;helloOWorldNotheloWhy??helhellelo&quot;; char str2[1024]=&quot;hellelo&quot;; printf(&quot;%d\\n&quot;,hash_machting(str2,str1)); return 0; &#125;","categories":[],"tags":[{"name":"data-structure","slug":"data-structure","permalink":"https://LTitan.github.io/tags/data-structure/"}]},{"title":"数据结构(一)单链表、栈、和队列","slug":"数据结构(一)单链表、栈、和队列 ","date":"2018-07-15T04:16:59.000Z","updated":"2018-09-25T09:41:34.895Z","comments":true,"path":"2018/07/15/数据结构(一)单链表、栈、和队列 /","link":"","permalink":"https://LTitan.github.io/2018/07/15/数据结构(一)单链表、栈、和队列 /","excerpt":"","text":"看到实验室这么多考研的童鞋，自己觉得得去分享点东西把，把自己会的分享给他们吧。 这次只是单链表的创建、插入、删除、查找 单链表的c语言代码加详细注释，双向链表和循环链表待更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;//申请和释放内存用//前提说明 所有的i++ 用 ++i使用，i++需要额外的寄存器 ++i则反，提高运行效率//如有内存泄漏及溢出或者野指针情况 请及时提出//带头节点的单链表typedef struct _linked_list&#123; int data;//这里只是用了一个int当作测试数据，自己可以改 struct _linked_list *next;//尾指针&#125;linkedList;//重新命名void traversing(linkedList *List)//遍历链表&#123; linkedList *p=List-&gt;next;//遍历指针p先指向list的第一个位置 而不是头节点位置 while(p!=NULL) &#123; printf(&quot;%d &quot;,p-&gt;data); p=p-&gt;next;//不断往下指 &#125; printf(&quot;\\n&quot;);//最后换行&#125;void create_tail(linkedList *List,const int n)//尾插法 n表示要插入的个数&#123; linkedList *tail=List; tail-&gt;next=NULL;//先将尾巴放在链表头的位置，然后才进行尾插 int temp;//输入值的中间变量 for(int i=0;i&lt;n;++i) &#123; printf(&quot;请输入第%d节点的数值\\n&quot;,i+1); scanf(&quot;%d&quot;,&amp;temp);//输入数值 linkedList *newNode=(linkedList*)malloc(sizeof(linkedList));//申请一个新的节点 newNode-&gt;data=temp;//数值拷贝 tail-&gt;next=newNode;//尾巴的下一个指向新节点 newNode-&gt;next=NULL;//新节点后面没有节点了 tail=newNode;//新节点变成尾巴 &#125;&#125;int insert_node(linkedList *list,int pos,int data)//pos即插入位置 data即数值&#123; //原理基本上和创建的相似 //因为c语言没有bool类型 只能用int类型的返回值 //链表的下标是从1开始的，头节点(没有数值)算0下标，自己也可以修改 if(pos&lt; 1|| list==NULL) return -1;//插入位置小于1 或者 链表为空 直接失败 linkedList *head=list;//先指向头节点 int i=0;//计数 找到插入位置的前驱 while(head!=NULL) &#123; if(i==pos-1) break;//找到前驱结点就停止 ++i; head=head-&gt;next; &#125; if(i&lt;pos-1) return -1;//pos长度超过链表长度 插入失败 linkedList *newNode=(linkedList*)malloc(sizeof(linkedList));//新的节点 newNode-&gt;data=data; newNode-&gt;next=NULL; linkedList *temp;//中间无意义节点 temp=head-&gt;next; head-&gt;next=newNode; newNode-&gt;next=temp; return 1;//插入成功&#125;int select_list(linkedList *list,int x)//查找数值 返回下标数组 不仅仅查找一个数值&#123; int i=1; linkedList *p=list-&gt;next;//遍历指针指向第一个,同上 //计数 j为arr的长度 while(p!=NULL) &#123; if(p-&gt;data==x) return i;//找到返回下标 ++i; p=p-&gt;next; &#125; //找不到返回-1 return -1; //拓展：查找的值不可能是唯一的，可以返回下标数组&#125;int delete_list(linkedList *list,int pos)&#123; linkedList *p=list; if(pos&lt;1||list==NULL) return -1;//删除失败 int i=0; while(p!=NULL) &#123; if(i==pos-1) break;//找到前驱结点 ++i; p=p-&gt;next; &#125; if(i&lt;pos-1) return -1;//查找失败，越界 linkedList *temp=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next; free(temp); return 1;&#125;int main()&#123; const int n=5; linkedList *mylist; mylist=(linkedList*)malloc(sizeof(linkedList));//先新建一个头节点 mylist-&gt;next=NULL; //大部分的函数我传参都是传的链表的地址 create_tail(mylist,n);//新建 traversing(mylist);//遍历 //插入操作 位置3 数值666 自己也可以输入 int flag=insert_node(mylist,3,666); if(flag!=-1) puts(&quot;插入成功,链表如下&quot;); else puts(&quot;插入失败,链表如下&quot;); traversing(mylist); //查找666的位置 肯定是3 因为上边刚插入的 //查找能做到了 修改也是easy的 printf(&quot;查找的位置%d\\n&quot;,select_list(mylist,666)); flag=delete_list(mylist,4);//删掉第4个 if(flag!=-1) puts(&quot;删除成功,链表如下&quot;); else puts(&quot;删除失败,链表如下&quot;); traversing(mylist); //拓展：将遍历链表改为求链表的长度，自己把头插法补充上吧 return 0;&#125; 栈： 了解了基本性质就行了，c语言版的没必要，附上c++版的栈类，及常用方法 123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;//stack 为模板类 &lt;&gt; 里面用来放数据类型stack&lt;char&gt; mystack;int main()&#123; //empty 函数使用 返回bool值 空为true if(mystack.empty()) puts(&quot;栈是空的&quot;); //push 入栈 pop 出栈 top 返回栈顶数值&lt;&gt;里面的类型 mystack.push(&apos;h&apos;);//1 mystack.push(&apos;e&apos;);//2 mystack.push(&apos;l&apos;);//3 mystack.push(&apos;l&apos;);//4 mystack.push(&apos;o&apos;);//5 while(!mystack.empty()) &#123; char temp=mystack.top(); mystack.pop(); printf(&quot;%c &quot;,temp); &#125;//打印 o l l e h //size 即栈的大小 此时以及pop完毕 栈为空size为0 printf(&quot;\\n栈的大小为%d\\n&quot;,mystack.size()); return 0;&#125; 福利：附上一个常用好玩东西 啥都能放的数组vector 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;//算法头文件using namespace std;//切记一定有 命名空间std//vector 为模板类 &lt;&gt; 里面用来放数据类型typedef pair&lt;int,int&gt; Point;/*对组 pair &lt;type,type&gt; 能放下一对数据，常用来表示坐标啊，对应关系啊pair.fist 顾名思义 第一个数据嘛 pair.second 表示第二个数据pair&lt;int,int&gt; 我把它定义成新的数据类型 坐标*/vector&lt;Point&gt; point_arr;/*先说一下构造函数 vector(int) 表示一个长为n数值全为0的数组啥也没有的话默认为空数组 size() 可以检测出来*/bool cmp(const Point a,const Point b);//这个先不用管，下文继续说int main()&#123; //push_back 什么back？ 那有没有front？ //对不起 没有 在一个线性数组里面往前插入一个数的时间复杂度是O(n) //插一个O（n） 插n个就是O（n^2） 效率可想而知 point_arr.push_back(Point(1,1)); point_arr.push_back(Point(1,-3)); point_arr.push_back(Point(2,4)); point_arr.push_back(Point(-12,8)); point_arr.push_back(Point(7,6));//在数组里面放入5个点 //我想按照y的大小从小到大 把这些点拍个序怎么排 //冒泡？太慢了 归并排序？自己又写不出来 //这时候 c++的好用之处就来了,看下一行代码 和最后一个函数 sort(point_arr.begin(),point_arr.end(),cmp); //begin 就相当于首指针 end 就相当于尾指针 两个相减就是数组大小 //不信的话可以试试，只不过stl把指针简化了，变安全了，改叫迭代器了 //cmp 就是上文的注释函数 即为排序函数，这个函数可以自己写，想怎么排就怎么排 //就是调用了系统的 快速排序函数 sort（） //排序完了 就得打印了，是不是得pop啊 //这里可以不用pop 万一这些数据还用呢，pop了就没了 //这里可以用运算符重载 [] 直接用到下标，注意是否越界 puts(&quot;y从小到大的结果:&quot;); for(unsigned int i=0;i&lt;point_arr.size();++i) printf(&quot;(%d,%d)\\n&quot;,point_arr[i].first,//x point_arr[i].second//y ); //上面是用[] 可不可以用指针呢？可以，不过叫做迭代器 // iterator 这个类型的都叫迭代器 puts(&quot;遍历2:&quot;); vector&lt;Point&gt;::iterator itor;//创建一个迭代器对象 for(itor=point_arr.begin();itor!=point_arr.end();itor++) &#123; //注意指针的自增运算符 ++ 就是移动指针一个位置 printf(&quot;(%d,%d)\\n&quot;,itor-&gt;first,//x itor-&gt;second//y ); &#125; //自己写一个按照x排序的吧 return 0;&#125;bool cmp(const Point a,const Point b)&#123; //按照y的大小排序 所以只看second 就行了 //a b 是有顺序的 第一个参数永远在第二个前面 if(a.second&lt;b.second) return true;//后面比前面小就是true 从小到大 简单易懂 return false;&#125;","categories":[],"tags":[{"name":"data-structure","slug":"data-structure","permalink":"https://LTitan.github.io/tags/data-structure/"}]},{"title":"操作系统--页面置换算法","slug":"页面置换算法","date":"2018-06-16T02:16:59.000Z","updated":"2018-09-25T09:46:40.574Z","comments":true,"path":"2018/06/16/页面置换算法/","link":"","permalink":"https://LTitan.github.io/2018/06/16/页面置换算法/","excerpt":"","text":"###最佳置换算法 本人只是简单的列举三种算法的解题过程，但是实际问题得具体分析，感谢刘静文学姐，对缺页率的计算加已改正。 假设系统给某进程分配了三个物理块，有以下的页面号引用串： 则前三次装入内存并未发生中断，但是缺页，如下: 第四次时，在页中未发现2,发生缺页中断，根据最佳置换算法，发生一下操作： 即舍弃内存页中引用串下次出现的最大值 == &lt;7,0,1&gt; -&gt; &lt;2,0,1&gt; == 第五次时0存在，不会发生缺页中断 第六次3在内存页中未找到，缺页中断发生，置换： == &lt;2,0,1&gt; -&gt; &lt;2,0,3&gt; == …… 依次类推，最后结果如下： &lt;2,7,1&gt; 缺页率为： 前三次未发生缺页中断，但是需要调入内存，仍属于缺页范围。 前三次加上红框缺页次数6 总次数17 f=(6+3)/17×100%=52.9% FIFO 算法 先进先出算法 还是以前的数据，有三个物理块，数据如下,且前三次不会发生缺页中断： 第四次时发生，缺页中断，先进先出算法：7先进的，所以7先出： == &lt;7,0,1&gt; -&gt; &lt;2,0,1&gt; == 第5次时未发生缺页中断 第六次时，3未找到，发生缺页中断，如下： == &lt;2,0,1&gt; -&gt; &lt;2,3,1&gt; == 依次类推，最终结果如下： &lt;7,1,2&gt; 缺页率计算如下： 前三次未发生缺页中断，但是需要调入内存，仍属于缺页范围。 前三次加上红框缺页次数10 总次数17 f=(10+3)/17×100%=76.5% 这个算法比上者算法接近多一倍 ##LRU算法（最近最久未使用） 还是如上数据，前三次结果未改变： 第四次时，和FIFO算法一致： == &lt;7,0,1&gt; -&gt; &lt;2,0,1&gt; == 第五次未改变，第六次发生缺页中断，如下，最好比较FIFO和LRU的区别： == &lt;2,0,1&gt; -&gt; &lt;2,0,3&gt; == 依次类推，最后结果如下： &lt;1,7,2&gt; 缺页率计算如下： 前三次未发生缺页中断，但是需要调入内存，仍属于缺页范围。 前三次加上红框缺页次数8 总次数17 f=(8+3)/17×100%=64.7%","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://LTitan.github.io/tags/OS/"}]},{"title":"进程同步问题","slug":"进程同步问题","date":"2018-06-13T02:16:59.000Z","updated":"2018-09-25T09:51:17.471Z","comments":true,"path":"2018/06/13/进程同步问题/","link":"","permalink":"https://LTitan.github.io/2018/06/13/进程同步问题/","excerpt":"","text":"#读写者问题(多个) 123456789101112131415161718192021222324252627282930313233343536373839404142int wmutex=1,rmutex=1;//读写信号量 int readCount=0;//读者数量 void Writer(); void Reader(); int main() &#123; cobegin Reader(); Writer(); coend; &#125; //写者： void Writer() &#123; while(1)&#123; P(wmutex); ... 写书 ... V(wmutex); &#125; &#125; //读者 void Reader() &#123; while(1) &#123; P(rmutex); if(readCount==0) P(wmutex); readCount++; V(rmutex); ... 读书 ... P(rmutex); readCount--; if(readCount==0) V(wmutex); V(rmutex); &#125; &#125; #哲学家就餐问题 123456789101112131415161718192021222324252627282930int chopstick[]=&#123;1,1,1,1,1&#125;;//五个筷子 int mutex=1; int main() &#123; cobegin switch(i) &#123; V(SB); case 1~5: Pi();break; &#125; coend; &#125; Pi()//第i个哲学家进餐 &#123; while(1) &#123; P(mutex); //在取筷子前获得互斥量 P(chopstick[i]); //取左边筷子 P(chopstick[(i+1)%5]); //取右边筷子 V(mutex); //释放取筷子的信号量 ... eat; //进餐 ... V(chopstick[i]); //放回左边筷子 V(chopstick[(i+1)%5]); //放回右边筷子 ... think;//思考 ... &#125; &#125; #生产者消费者问题 == 一个生产者 一个消费者 一个缓冲器：== 12345678910111213141516171819202122232425262728293031323334int buffer;//1 表示生产 0表示消费 int empty=1,full=0;//空和满 void producer(); void consumer(); int main() &#123; cobegin producer(); consumer(); coend; &#125; void producer() &#123; while(1) &#123; ... 生产 ... P(empty); buffer=1; V(full); &#125; &#125; void consumer() &#123; while(1) &#123; P(full); buffer=0; V(empty); ... 消费 ... &#125; &#125; 一个生产者 一个消费者 n个缓冲器： 123456789101112131415161718192021222324252627282930313233343536int buffer[1024],t=0,k=0; int empty=1,full=0; void producer(); void consumer(); int main() &#123; cobegin producer(); consumer(); coend; &#125; void producer() &#123; while(1) &#123; ... 生产 ... P(empty); buffer[k]=1; k=(++k)%n; V(full); &#125; &#125; void consumer() &#123; while(1) &#123; P(full); buffer[t]=0; t=(++t)%n; V(empty); ... 消费 ... &#125; &#125; #司机与售票员问题 1234567891011121314151617181920212223242526272829303132int s1=0,s2=0; void P1();//司机 void P2();//售票员 int main() &#123; cobegin P1(); p2(); coend; &#125; void P1() &#123; while(1)&#123; P(s1); ... 启动 正常行驶 到站 ... V(s2); &#125; &#125; void P2() &#123; while(1) &#123; 关门 V(s1); 售票 P(s2); 开门 &#125; &#125; #吃水果 问题描述 桌子上有一只盘子，最多可容纳两个水果，每次只能放人或取出一个水果。爸爸专向盘子中放苹果(apple)，妈妈专向盘子中放桔子(orange)，1个儿子专等吃盘子中的桔子，1个女儿专等吃盘子中的苹果。请用P、V操作来实现爸爸、妈妈、儿子、女儿之间的同步与互斥关系。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int mutex=1; int empty=2; int apple=0,orange=0; void father(), mother(); void son(),daughter(); int main() &#123; cobegin father(); mother(); son(); daughter(); coend; &#125; void father() &#123; while(1) &#123; P(empty); P(mutex); put an apple; V(mutex); V(apple); &#125; &#125; void mother() &#123; while(1) &#123; P(empty); P(mutex); put an orange; V(mutex); V(orange); &#125; &#125; void son() &#123; while(1) &#123; P(orange); P(mutex); eat an oeange; V(mutex); V(empty); &#125; &#125; void daughter() &#123; while(1) &#123; P(apple); P(mutex); eat an apple; V(mutex); V(empty); &#125; &#125; #独木桥问题 某条河上只有一座独木桥，以便行人过河。现在河的两边都有人要过桥，按照下面的规则过桥。为了保证过桥安全，请用P、V操作分别实现正确的管理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int SA=1,SB=1,mutex=1; int countA=0,countB=0; void A(),B(); int main() &#123; cobegin A(); B(); coend; &#125; void A() &#123; P(SA); if(countA==0) &#123; P(mutex); countA++; &#125; V(SA); 过独木桥; P(SA); countA--; if(countA==0) &#123; V(metux); &#125; V(SA); &#125; void B() &#123; P(SB); if(countB==0) &#123; P(mutex); countB++; &#125; V(SB); 过独木桥; P(SB); countB--; if(countB==0) &#123; V(metux); &#125; V(SB); &#125;","categories":[],"tags":[{"name":"OS","slug":"OS","permalink":"https://LTitan.github.io/tags/OS/"}]},{"title":"OpenCV 蒙太奇效果","slug":"OpenCV 蒙太奇效果","date":"2018-06-08T03:30:22.000Z","updated":"2018-10-24T12:35:01.264Z","comments":true,"path":"2018/06/08/OpenCV 蒙太奇效果/","link":"","permalink":"https://LTitan.github.io/2018/06/08/OpenCV 蒙太奇效果/","excerpt":"","text":"展示一下图片的效果 原图 效果图 拼接图 代码区：注释即为思想 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;sstream&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;using namespace cv;using namespace std;int main(int argc, char *argv[])&#123; Mat src=imread(\"/media/lyf/doc/蒙太奇/change.jpeg\"); if(src.empty()) &#123; return -1; &#125; resize(src,src,Size(),0.5,0.5); //长宽能放下多少张小图片 int rows=src.rows,cols=src.cols; int much_row=rows/50,much_col=cols/50; much_col=much_col*50&lt;cols?much_col+1:much_col; much_row=much_row*50&lt;rows?much_row+1:much_row; Mat over=Mat(much_row*50,much_col*50,CV_8UC3,Scalar(255,255,255)); srand(time(NULL)); Mat micPic,temp; for(int i=0;i&lt;much_row;++i) &#123; for(int j=0;j&lt;much_col;++j) &#123; //读取拼接的图片 std::string filename=\"/media/lyf/doc/蒙太奇/m\"; std::stringstream ss; ss&lt;&lt;rand()%22+1; filename+=ss.str()+\".jpeg\"; //cout&lt;&lt;filename&lt;&lt;endl; micPic=imread(filename,CV_LOAD_IMAGE_UNCHANGED); if(micPic.empty()) &#123; cout&lt;&lt;\"读取过程中出现错误\"&lt;&lt;endl; return -1; &#125; //cout&lt;&lt;micPic.channels()&lt;&lt;endl; resize(micPic,micPic,Size(50,50)); temp=Mat(over,Rect(j*50,i*50,50,50)); micPic.copyTo(temp); micPic.release(); &#125; &#125; //将图片转为 float类型的便于比例的分割 Mat src_32f,over_32f; src.convertTo(src_32f,CV_32FC3); over.convertTo(over_32f,CV_32FC3); for(int i = 0; i &lt; rows; ++i) &#123; for(int j = 0; j &lt; cols; ++j) &#123; //黄金比列 over_32f.at&lt;Vec3f&gt;(i, j)[0] = saturate_cast&lt;float&gt;(0.382*over_32f.at&lt;Vec3f&gt;(i, j)[0]+0.618*src_32f.at&lt;Vec3f&gt;(i, j)[0]); over_32f.at&lt;Vec3f&gt;(i, j)[1] = saturate_cast&lt;float&gt;(0.382*over_32f.at&lt;Vec3f&gt;(i, j)[1]+0.618*src_32f.at&lt;Vec3f&gt;(i, j)[1]); over_32f.at&lt;Vec3f&gt;(i, j)[2] = saturate_cast&lt;float&gt;(0.382*over_32f.at&lt;Vec3f&gt;(i, j)[2]+0.618*src_32f.at&lt;Vec3f&gt;(i, j)[2]); &#125; &#125; //转为正常图片格式 uchar over_32f.convertTo(over,CV_8UC3); over=Mat (over,Rect(0,0,cols,rows)); imshow(\"原图\",src); imshow(\"生成的\",over); resize(over,over,Size(),1.5,1.5); imwrite(\"over.jpeg\",over); waitKey(0); return 0;&#125;","categories":[],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://LTitan.github.io/tags/opencv/"}]},{"title":"转移linux（一）qt+opencv3.3视频播放器加摄像头读取","slug":"转移linux（一）qt+opencv3.3视频播放器加摄像头读取","date":"2018-06-01T01:30:22.000Z","updated":"2018-10-24T12:40:07.035Z","comments":true,"path":"2018/06/01/转移linux（一）qt+opencv3.3视频播放器加摄像头读取/","link":"","permalink":"https://LTitan.github.io/2018/06/01/转移linux（一）qt+opencv3.3视频播放器加摄像头读取/","excerpt":"","text":"windows MFC c# 玩不了了 打算走嵌入式线路了 从opencv自己编译了n天，到今天第一个qt项目，差不多两周吧，自己电脑实体机装了**deep in linux ** 和 windows双系统，所以体验体验linux编程的乐趣 QT cteater的设计师界面效率快的不要不要的，更何况是c++，而且还吹嘘的什么跨平台。 附上开发的设计图 软件截图: 界面来讲还好吧，比mfc好看，主要视频还是用到QT自带的多线程来逐帧播放的，调试了5个小时，哈哈哈还是挺欣慰的，以后打算入手树梅派来做项目了。 就简单的附上视频的按钮以及核心代码吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596void MainWindow::on_openFileBtn_clicked()&#123; // 打开视频文件按钮 有播放的视频的话会先停止 isOpenFile=true; if(capture.isOpened()) &#123; capture.release(); &#125; //文件类型的对话框 不需要用指针新建一个类 //自行可以添加视频格式 QString FileName=QFileDialog::getOpenFileName(this,tr(\"打开文件\"),\".\", tr(\"Video Files(*.avi *.mp4 *.flv)\")); // capture.open(FileName.toLocal8Bit.data()); //防止字符串乱码转化 capture.open(FileName.toStdString());//字符串(全英文目录比较好)的转化 if(capture.isOpened()) &#123; rate=capture.get(CV_CAP_PROP_FPS); if(isOpenFile) &#123; vd_x=capture.get(CV_CAP_PROP_FRAME_COUNT); ui-&gt;videoLong-&gt;setRange(0,vd_x); &#125; capture&gt;&gt;frame; if(!frame.empty()) &#123; //自适应窗口大小 width_x=ui-&gt;ImageLabel-&gt;width()*1.0/frame.cols; height_x=ui-&gt;ImageLabel-&gt;height()*1.0/frame.rows; cv::resize(frame,frame,Size(),width_x,height_x); image=Mat2QImage(frame); //显示在label上 ui-&gt;ImageLabel-&gt;setPixmap(QPixmap::fromImage(image)); timer=new QTimer(this); //定时器线程 时间设置 相当与帧率 timer-&gt;setInterval(1000/rate); connect(timer,SIGNAL(timeout()),this,SLOT(nextFrame())); timer-&gt;start(); &#125; &#125; return;&#125;QImage Mat2QImage(Mat cvImg)&#123; //Mat 类型转 QImage 类似与Mat转bitmap QImage qImg; //判断通道个数 if(cvImg.channels()==3) &#123; cvtColor(cvImg,cvImg,CV_BGR2RGB); qImg=QImage((const unsigned char *)(cvImg.data), cvImg.cols,cvImg.rows, cvImg.cols*cvImg.channels(), QImage::Format_RGB888 ); &#125; else if(cvImg.channels()==1) &#123; qImg=QImage((const unsigned char *)(cvImg.data), cvImg.cols,cvImg.rows, cvImg.cols*cvImg.channels(), QImage::Format_Indexed8 ); &#125; else &#123; qImg=QImage((const unsigned char *)(cvImg.data), cvImg.cols,cvImg.rows, cvImg.cols*cvImg.channels(), QImage::Format_RGB888 ); &#125; return qImg;&#125;void MainWindow::nextFrame()&#123; capture&gt;&gt;frame; if(!frame.empty()) &#123; //调整大小 cv::resize(frame,frame,Size(),width_x,height_x); image=Mat2QImage(frame); ui-&gt;ImageLabel-&gt;setPixmap(QPixmap::fromImage(image)); if(isOpenFile) &#123; ui-&gt;videoLong-&gt;setValue((int)(capture.get(CV_CAP_PROP_POS_FRAMES))); &#125; &#125;&#125;","categories":[],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://LTitan.github.io/tags/opencv/"}]},{"title":"图论--最短路径和最小生成树","slug":"图论--最短路径和最小生成树","date":"2018-04-25T09:30:22.000Z","updated":"2018-10-24T12:41:45.117Z","comments":true,"path":"2018/04/25/图论--最短路径和最小生成树/","link":"","permalink":"https://LTitan.github.io/2018/04/25/图论--最短路径和最小生成树/","excerpt":"","text":"######图的表示呢分为邻接矩阵和邻接链表。其主要算法层出不穷，这里主要介绍最短路径的ford和dijsktra，单源最短路径，思维可能有点局限，有什么好的想法可以联系我，代码有如雷同，不怨俺. (数组d[]表示求解的各点最短路径，from表示来源点，to表示目的点，cost表示权值，e(i,j)表示从i到j的边 ) 题目来源： 小木乃伊到我家 输入描述: 第一行输入两个整数n和m（2&lt;=n&lt;=m&lt;=200000），分别表示有n座城市和m条路，城市编号为1~n（快递姐姐所在城市为1，AA所在城市为n）。 接下来m行，每行输入3个整数u,v,w（u,v&lt;=n，w&lt;=100000），分别表示城市u和城市v之间有一条长为w的路。 输出描述: 输出结果占一行，输出快递姐姐到达AA家最短需要走多远的路，如果没有路能走到AA家，则输出“qwb baka”（不用输出双引号）。 示例1 12345678输入4 41 2 12 3 23 4 32 3 1输出5 Ford 算法解决 递推公式呢就是 d[i]=min{d[j]+cost[i][j]} 但是这个效率比较低啊，时间O(e^2)，这个算法程序就不详解了； 代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;#define MAX_E 200005#define INF 0x3f3f3f3f#include &lt;time.h&gt;struct edge&#123;int from,to,cost;&#125;;edge es[MAX_E];//变 起点 终点 权值int d[MAX_E];//最短距离int V,E;//顶点数 边数void WithMax()&#123; for(int i=1;i&lt;=V;i++) d[i]=INF;&#125;void the_short_path(int s)//起点为s&#123; WithMax(); // fill(d,d+V,INF); d[s]=0;//起点的距离为0 while(1) &#123; bool update=false; for(int i=1;i&lt;=E;i++)&#123; edge e=es[i]; if(d[e.from]!=INF&amp;&amp;d[e.to]&gt;(d[e.from]+e.cost)) &#123; d[e.to]=d[e.from]+e.cost; update=1; &#125; &#125; if(update==false) break; &#125;&#125;int main()&#123; while(cin&gt;&gt;V&gt;&gt;E) &#123; clock_t start_time,end_time; start_time=clock(); for(int i=1;i&lt;=E;i++) cin&gt;&gt;es[i].from&gt;&gt;es[i].to&gt;&gt;es[i].cost; the_short_path(1); if(d[V]==INF) cout&lt;&lt;\"qwbbaka\"&lt;&lt;endl; else cout&lt;&lt;d[V]&lt;&lt;endl; end_time=clock(); cout&lt;&lt;\"运行时间: \"&lt;&lt;(double)(end_time-start_time)/CLOCKS_PER_SEC&lt;&lt;endl; &#125; return 0;&#125; ####迪杰斯特拉算法 引入(楼主可能是太特么懒了)： 上图所示的图，求0到各个点的最短距离 具体原理如下，最后填充的哪个点进集合的位置，就是加上之前的最小距离 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define MAX_A 200005#define INF 0x3f3f3f#define ll long long#include &lt;time.h&gt;struct node&#123; ll to,cost; node()&#123;&#125; node(ll x,ll y) &#123; to=x; cost=y; &#125; bool operator &lt; (const node &amp;a) const &#123; return cost&gt;a.cost; &#125;&#125;;ll V,E;//顶点数和边数vector&lt;node&gt; G[MAX_A];ll vis[MAX_A];ll d[MAX_A];void dijkstra()//参数为起点&#123; //初始化 fill(vis,vis+V+1,0); fill(d,d+V+1,INF); d[1]=0; priority_queue&lt;node&gt; que; que.push(node(1,0)); while(!que.empty()) &#123; node e=que.top(); que.pop(); if(vis[e.to]) continue; vis[e.to]=1; for(unsigned long i=0;i&lt;G[e.to].size();i++) &#123; ll to=G[e.to][i].to,cost=G[e.to][i].cost; if(!vis[to] &amp;&amp; d[to]&gt;d[e.to]+cost) &#123; d[to]=d[e.to]+cost; que.push(node(to,d[to])); &#125; &#125;&#125;&#125;int main()&#123; ll f,t,c; while(cin&gt;&gt;V&gt;&gt;E) &#123; clock_t start_t,end_t; start_t=clock(); for(ll i=1;i&lt;=V;i++) G[i].clear(); for(ll i=0;i&lt;E;i++) &#123; cin&gt;&gt;f&gt;&gt;t&gt;&gt;c; G[f].push_back(node(t,c)); G[t].push_back(node(f,c)); &#125; dijkstra(); cout&lt;&lt;d[V]&lt;&lt;endl; end_t=clock(); cout&lt;&lt;(double)(end_t-start_t)/CLOCKS_PER_SEC&lt;&lt;endl; &#125;&#125;","categories":[],"tags":[{"name":"data-structure","slug":"data-structure","permalink":"https://LTitan.github.io/tags/data-structure/"}]},{"title":"VS 自带数据库 MSSQLLocalDB 的使用方法","slug":"VS-自带数据库-MSSQLLocalDB-的使用方法","date":"2018-04-18T05:30:22.000Z","updated":"2018-10-24T12:39:02.190Z","comments":true,"path":"2018/04/18/VS-自带数据库-MSSQLLocalDB-的使用方法/","link":"","permalink":"https://LTitan.github.io/2018/04/18/VS-自带数据库-MSSQLLocalDB-的使用方法/","excerpt":"","text":"话说数据库开课了，机房用的是SQL server2008 r2,微软的这个东西有点大，但是已经有vs的童鞋有福利了，因为vs自带一个MSSqlLocalDatabase ，就是一个本地链接的数据库，我这里演示的是VS2015教程，2013、2017应该都可以的。 ##下面开始教程 #####首先打开vs 1、找到菜单栏，点击工具，找到连接SQL Server，如下图 2、然后会弹出这个窗口，选择本地，选择MsSqlLocalDB，然后连接，注意一定是windows验证才可以，如图 3、会在VS侧栏有个 SQl Server对象资源管理器，如下图，没找到这个窗口的，再看下个图 4、打开这个数据库，就是那个小箭头，添加新数据库，我这个例子呢是用的教材P71 的习题6，你们也可以换其他的测试 5、经常用的，起个新名字，放个路径 6、打开这个新建的数据库（小箭头），然后鼠标右键，新建查询 7、写你自己定义的SQL语句，然后执行脚本，最后刷新数据库，就会完成操作 8、最后给表添加数据，这里先不考虑SQL语言插入了，显示表之后，自己往上填就行了 除掉了烦人的sqlserver安装，还是挺省事吧。","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://LTitan.github.io/tags/others/"}]},{"title":"OpenCV 帧差法运动物体追踪","slug":"OpenCV-帧差法运动物体追踪","date":"2018-03-28T06:30:20.000Z","updated":"2018-10-24T12:32:55.870Z","comments":true,"path":"2018/03/28/OpenCV-帧差法运动物体追踪/","link":"","permalink":"https://LTitan.github.io/2018/03/28/OpenCV-帧差法运动物体追踪/","excerpt":"","text":"最近迷上了物体跟踪的玩意,于是乎找了好多视频去看，翻来覆去呢就是用到了轮廓检测的api，还有耐心的不断的调试。 原理呢是帧差法（就是一帧一帧的比较）非HSV分离 看看视频 软件的工作流程 您的浏览器不支持 video 标签。 代码呢，emmm，真的是不好理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#include&lt;opencv2/opencv.hpp&gt;#include&lt;opencv2/highgui/highgui.hpp&gt;#include&lt;opencv/cv.h&gt;#include&lt;opencv/highgui.h&gt;using namespace std;using namespace cv;const static int SEAITVITV_VALUE = 20; //阈值操作的起始范围 可手动调试const static int BLUR_SIZE = 10;//blur 滤波Size大小int theObject[2] = &#123; 0,0 &#125;;//发现目标的坐标 x,yRect objectBoundingRect = Rect(0, 0, 0, 0);//目标跳动的矩形string intTostring(int num)&#123;//int 类型 转为 stringstringstream ss;ss &lt;&lt; num;return ss.str();&#125;void searchForMovement(Mat thresgoldImage, Mat &amp;cameraFeed)&#123; //寻找移动物Mat temp;bool objectDetected;//形参的阈值图像传给中间变量thresgoldImage.copyTo(temp);//向量 用来存放轮廓点坐标 Pointvector &lt; vector&lt;Point&gt; &gt; contours;//向量 用来存放层次vector&lt;Vec4i&gt; hierarchy;//调用api 来获取层次和轮廓点findContours(temp, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);//判断轮廓点的个数是否为0if (contours.size() &gt; 0) objectDetected = true;else &#123; objectDetected = false; &#125;if (objectDetected)&#123; //找最大的轮廓点 vector&lt;vector&lt;Point&gt; &gt; largesContours; largesContours.push_back(contours.at(contours.size() - 1)); objectBoundingRect = boundingRect(largesContours.at(0)); //约找出接近中心位置的点 int xpos = objectBoundingRect.x + objectBoundingRect.width / 2; int ypos = objectBoundingRect.y + objectBoundingRect.width / 2; //传给全局变量暂放坐标 theObject[0] = xpos; theObject[1] = ypos;&#125;int x = theObject[0];int y = theObject[1];//画一个圆圈circle(cameraFeed, Point(x, y), 20, Scalar(0, 255, 0), 2);//画十字架line(cameraFeed, Point(x, y), Point(x, y - 25),Scalar(0,255,0),2);line(cameraFeed, Point(x, y), Point(x, y + 25), Scalar(0, 255, 0), 2);line(cameraFeed, Point(x, y), Point(x-25, y ), Scalar(0, 255, 0), 2);line(cameraFeed, Point(x, y), Point(x+25, y ), Scalar(0, 255, 0), 2);//输出坐标putText(cameraFeed, \"tracking at:(\" + intTostring(x) + \",\" + intTostring(y) + \")\", Point(x, y), 1, 1, Scalar(0, 255, 0));&#125;int main()&#123;//按键是否调试bool debugMode = false;//按键是否跟踪bool trackingEnable = false;//是否暂停视频bool pause = false;//视频取帧的frame1 frame2Mat frame1, frame2;//上者灰度图像Mat gray1, gray2;//两者的不同图像Mat differenceImg;//视频类VideoCapture capture;//阈值后的图像Mat thres;while (1)//不断的播放视频 进行调试&#123; capture.open(\"3.mp4\"); if (!capture.isOpened()) &#123; //打开视频失败 return -2; &#125; //int total = capture.get(CV_CAP_PROP_FRAME_COUNT); //cout &lt;&lt; total &lt;&lt; endl; //获取当前帧 与总帧进行比较 从而循环 while (capture.get(CV_CAP_PROP_POS_FRAMES) &lt; capture.get(CV_CAP_PROP_FRAME_COUNT) - 1) &#123; //捕获frame1 capture.read(frame1); //转为灰度图 cvtColor(frame1, gray1, COLOR_BGR2GRAY); //捕获frame2 capture.read(frame2); //转为灰度图 cvtColor(frame2, gray2, COLOR_BGR2GRAY); //调用api 找出两者不同的区域 存入differenceImg absdiff(gray1, gray2, differenceImg); //阈值操作 threshold(differenceImg, thres, SEAITVITV_VALUE, 255, THRESH_BINARY); //滤波 去噪点 blur(thres, thres, Size(BLUR_SIZE, BLUR_SIZE)); //再进行一遍阈值 threshold(thres, thres, SEAITVITV_VALUE, 255, THRESH_BINARY); //是否进入调试模式 if (debugMode == true) &#123; imshow(\"thres\", thres); &#125; else &#123; //销毁窗口 destroyWindow(\"thres\"); &#125; //是否进入追踪捕获模式 if (trackingEnable) &#123; searchForMovement( thres, frame1); &#125; //显示原图像 imshow(\"frame\", frame1); switch (waitKey(50)) &#123; case 27: return 0; case 't': case 'T': &#123; trackingEnable = !trackingEnable; if (trackingEnable == false) cout &lt;&lt; \"没有捕获\" &lt;&lt; endl; else cout &lt;&lt; \"捕获开始\" &lt;&lt; endl; break; &#125; case 'd': case 'D': &#123; debugMode = !debugMode; if (debugMode == false) cout &lt;&lt; \"调试模式退出\\n\"; else cout &lt;&lt; \"进入调试模式\" &lt;&lt; endl; break; &#125; case 112: pause = !pause; if (pause == true) &#123; cout &lt;&lt; \"暂停\" &lt;&lt; endl; while (pause == true) &#123; switch (waitKey()) &#123; case 112: pause = false; break; &#125; &#125; &#125; else cout &lt;&lt; \"开始\" &lt;&lt; endl; break; &#125; &#125; //播放完后释放类 capture.release();&#125;&#125;","categories":[],"tags":[{"name":"opencv","slug":"opencv","permalink":"https://LTitan.github.io/tags/opencv/"}]},{"title":"新年？ 当然是烟花了！！！","slug":"新年?-当然是烟花了！！！","date":"2018-02-26T03:34:20.000Z","updated":"2018-10-24T12:43:41.411Z","comments":true,"path":"2018/02/26/新年?-当然是烟花了！！！/","link":"","permalink":"https://LTitan.github.io/2018/02/26/新年?-当然是烟花了！！！/","excerpt":"","text":"###唉 又过年了 过年咱也送个礼物了，烟花绽放.exe，献给你们 内容呢是在b站上跟大佬学的，还是用到了简单的easyX 绘图库 文件和源码呢，就在上传的文件里面，解压就能看到了。 我感觉就是烟花障眼法","categories":[],"tags":[{"name":"others","slug":"others","permalink":"https://LTitan.github.io/tags/others/"}]},{"title":"图的基本遍历算法 DFS and BFS","slug":"图的基本遍历算法-DFS-and-BFS","date":"2018-01-24T03:34:20.000Z","updated":"2018-10-24T12:45:31.023Z","comments":true,"path":"2018/01/24/图的基本遍历算法-DFS-and-BFS/","link":"","permalink":"https://LTitan.github.io/2018/01/24/图的基本遍历算法-DFS-and-BFS/","excerpt":"","text":"先介绍下DFS 下面这张图呢是图的原来状态 这个gif呢是其深度优先遍历的过程，ppt做的，可能会失真 遍历的思想有了，但是对于非稀疏图来讲利用图的邻接矩阵遍历效果是不是更好。 那么代码就来了； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;stack&gt;/*图的深度优先搜索数据结构中介绍需要用到栈的帮助这里的栈用C++ STL的stack*/using namespace std;#define number 5//定义图的邻接矩阵void DFS(int start);int map[][5]=&#123;0,1,1,0,0,0,0,1,0,1,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0&#125;;//访问过的顶点int visited[number + 1];int main()&#123;//初始化数组为0，表示一个也没访问memset(visited, 0, sizeof(visited));for (int i = 1; i &lt;= number; i++)&#123; if (visited[i] == 1) continue; DFS(i);&#125;system(&quot;pause&quot;);return 0;&#125;void DFS(int start)&#123;stack&lt;int&gt; stk;//顶点入栈stk.push(start);//表示访问visited[start] = 1;bool IS_PUSH = false;//是否有新的顶点入栈while (!stk.empty())&#123; IS_PUSH = false; int p = stk.top(); for (int i = 1; i &lt;= number; i++) &#123; if (map[p - 1][i - 1] == 1 &amp;&amp; !visited[i]) //如果他俩联通，并且还没有访问过 &#123; visited[i] = 1; stk.push(i); IS_PUSH = true;//新顶点入栈 break; &#125; &#125; if (!IS_PUSH) &#123; cout &lt;&lt; p &lt;&lt; &quot; &quot;; stk.pop();//顶点出栈 &#125;&#125;&#125; 运行结果，看图就能看出来了，不过代码只是更简单点了 BFS 代码用到队列 123456789101112131415161718192021222324void BFS(int start)&#123;queue&lt;int&gt; que;//顶点入队que.push(start);//表示访问visited[start] = 1;while (!que.empty())&#123; int p = que.front(); cout &lt;&lt; p &lt;&lt; &quot; &quot;; que.pop(); for (int i = 1; i &lt;= number; i++) &#123; if (map[p - 1][i - 1] == 1 &amp;&amp; !visited[i]) //如果他俩联通，并且还没有访问过 &#123; visited[i] = 1; que.push(i); &#125; &#125;&#125;&#125;","categories":[],"tags":[{"name":"data-structure","slug":"data-structure","permalink":"https://LTitan.github.io/tags/data-structure/"}]}]}